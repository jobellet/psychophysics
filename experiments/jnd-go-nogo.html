<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Just Noticeable Difference Go/No-Go</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="../jspsych/css/jspsych.css" />
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Inter", "Helvetica Neue", Arial, sans-serif;
      --bg: #d4d7dd;
      --card-bg: rgba(15, 23, 42, 0.9);
      --accent: #38bdf8;
      --stage-size: min(68vw, 68vh);
    }

    html, body { height: 100%; }
    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      background: var(--bg);
      color: #e2e8f0;
      padding: clamp(16px, 4vw, 48px);
      box-sizing: border-box;
      overflow-x: hidden;
      overflow-y: auto;
    }

    #pre-experiment {
      position: fixed; inset: 0;
      background: radial-gradient(circle at top, rgba(15,23,42,.96) 0%, rgba(2,6,23,.94) 100%);
      display: flex; align-items: center; justify-content: center;
      padding: clamp(24px, 6vw, 72px);
      overflow-y: auto; z-index: 10; transition: opacity 220ms ease;
    }
    #pre-experiment.hidden { opacity: 0; pointer-events: none; }

    .session-card {
      margin: auto; width: min(92vw, 720px); max-width: min(92vw, 720px);
      max-height: calc(100vh - clamp(48px, 12vw, 96px));
      background: rgba(15, 23, 42, 0.85);
      border-radius: clamp(24px, 4vw, 36px);
      box-shadow: 0 30px 70px rgba(2, 6, 23, 0.6);
      padding: clamp(28px, 6vw, 56px);
      display: flex; flex-direction: column; gap: clamp(16px, 4vw, 28px);
      overflow-y: auto; box-sizing: border-box;
    }

    .session-card h1 { margin: 0; font-size: clamp(1.6rem, 4vw, 2.15rem); }
    .session-card p  { margin: 0; color: rgba(203, 213, 225, 0.92); }

    .calibration-section {
      border: 1px solid rgba(148, 163, 184, 0.22);
      border-radius: clamp(18px, 3.5vw, 28px);
      padding: clamp(16px, 4vw, 28px);
      background: rgba(15, 23, 42, 0.6);
      display: flex; flex-direction: column; gap: clamp(12px, 3vw, 20px);
    }
    .calibration-section h2 { margin: 0; font-size: clamp(1.15rem, 3vw, 1.35rem); color: #f8fafc; }
    .calibration-section p.small-print { font-size: .95rem; color: rgba(148,163,184,.92); }

    .calibration-display {
      position: relative; width: 100%; min-height: clamp(160px, 45vw, 260px);
      border-radius: clamp(16px, 4vw, 24px); background: rgba(15,23,42,.72);
      border: 1px dashed rgba(148,163,184,.4);
      display: flex; align-items: center; justify-content: center; overflow: hidden;
      touch-action: none;
    }
    .calibration-instruction {
      position: absolute; top: 12px; left: 50%; transform: translateX(-50%);
      font-size: .9rem; letter-spacing: .02em; text-transform: uppercase;
      color: rgba(148,163,184,.88); pointer-events: none;
    }
    .calibration-shape {
      position: relative;
      border: 2px solid rgba(56,189,248,.85);
      background: rgba(56,189,248,.12);
      box-shadow: inset 0 0 0 1px rgba(148,163,184,.35);
      border-radius: clamp(8px, 2vw, 12px);
      transition: width .12s ease, height .12s ease, border-radius .12s ease;
    }
    .calibration-shape.circle { border-radius: 9999px; }

    .calibration-controls { display:flex; flex-wrap:wrap; gap: clamp(8px,2vw,16px); align-items:center; justify-content:space-between; }
    .calibration-controls label { font-size: 1rem; color: rgba(226,232,240,.92); }
    .calibration-controls input[type='number'] {
      width: clamp(90px, 24vw, 120px);
      padding: 10px 14px; border-radius: 12px; border: 1px solid rgba(148,163,184,.35);
      background: rgba(15,23,42,.75); color: #f8fafc; font-size: 1rem; -moz-appearance: textfield;
    }
    .calibration-controls input[type='number']::-webkit-outer-spin-button,
    .calibration-controls input[type='number']::-webkit-inner-spin-button { -webkit-appearance:none; margin:0; }

    .calibration-slider { display:flex; flex-direction:column; gap:6px; }
    .calibration-slider input[type='range'] { width:100%; }
    .calibration-slider span { font-size:.95rem; color: rgba(148,163,184,.9); align-self:flex-end; }

    .calibration-status { margin:0; font-size:.95rem; color: rgba(148,163,184,.88); }
    .calibration-status[data-state='error'] { color:#fca5a5; }
    .calibration-status[data-state='success'] { color:#a7f3d0; }

    .calibration-target { font-size:.95rem; color: rgba(148,163,184,.9); }

    .jspsych-btn.secondary {
      background: rgba(56,189,248,.18);
      color:#38bdf8; box-shadow: inset 0 0 0 1px rgba(56,189,248,.45);
    }
    .jspsych-btn.secondary:hover { background: rgba(56,189,248,.28); }

    .file-picker { position: relative; display: inline-flex; align-items:center; justify-content:center;
      border-radius:999px; padding:0; overflow:hidden; width:fit-content;
      background: rgba(148,163,184,.12); border:1px solid rgba(148,163,184,.18); cursor: pointer; }
    .file-picker input[type='file'] { position:absolute; inset:0; opacity:0; cursor:pointer; }
    .file-picker span { padding:12px 24px; font-weight:600; color:#e2e8f0; font-size:1.05rem; }

    .session-status { margin:0; font-size:1.05rem; color: rgba(148,163,184,.88); }
    .session-status[data-state='error'] { color:#fca5a5; }
    .session-status[data-state='warning'] { color:#facc15; }
    .session-status strong { color:#f8fafc; }

    .session-actions { display:flex; flex-wrap:wrap; gap:12px; }
    .session-actions .jspsych-btn:disabled { opacity:.55; cursor:not-allowed; }

    .psychometrics-output { border-top:1px solid rgba(148,163,184,.18); padding-top: clamp(16px,4vw,28px);
      display:flex; flex-direction:column; gap: clamp(16px,4vw,24px); }

    #jspsych-target {
      width: min(96vw, 860px);
      max-height: calc(100vh - clamp(48px, 10vw, 120px));
      background: rgba(15,23,42,.82);
      backdrop-filter: blur(18px);
      border-radius: 32px;
      box-shadow: 0 24px 60px rgba(2,6,23,.55);
      padding: clamp(24px,5vw,56px);
      margin: clamp(24px,5vw,56px) auto;
      overflow-y: auto; box-sizing: border-box;
    }

    .jspsych-display-element { font-size: clamp(18px,3vw,22px); line-height:1.7; min-height:100%; }

    .jspsych-btn {
      font-size: clamp(1rem, 2.6vw, 1.15rem);
      padding: clamp(12px,3vw,16px) clamp(24px,5vw,36px);
      border-radius: 999px; border: none;
      background: linear-gradient(135deg, var(--accent), #2563eb);
      color: white; font-weight: 600; box-shadow: inset 0 -2px 0 rgba(15,23,42,.25);
      transition: transform 160ms ease, box-shadow 160ms ease; touch-action: manipulation;
    }
    .jspsych-btn:active { transform: translateY(2px); box-shadow: inset 0 2px 0 rgba(15,23,42,.35); }

    .stage {
      position: relative;
      width: var(--stage-size);
      height: var(--stage-size);
      margin: 0 auto;
      background: var(--bg);
      border-radius: clamp(24px, 6vw, 36px);
      box-shadow: none; overflow: hidden;
      display: flex; align-items: center; justify-content: center;
    }

    .dot {
      position: absolute; left: 50%; top: 50%;
      border-radius: 999px; background: #ffffff; box-shadow: none;
      transform: translate(-50%,-50%); pointer-events: none; will-change: transform;
    }
    .fixation-dot {
      position: absolute; left:50%; top:50%; transform: translate(-50%,-50%);
      border-radius: 999px; background: #000000; pointer-events: none;
    }

    .response-text { font-size: clamp(18px,3.2vw,24px); color: rgba(226,232,240,.94); text-align:center; padding:24px; }
    .trial-progress { font-size: clamp(14px,2.5vw,16px); letter-spacing:.08em; text-transform:uppercase; color: rgba(148,163,184,.8); text-align:center; margin-bottom: 16px; }

    .control-button {
      position: fixed; z-index: 30; border: none; font-family: inherit; font-weight: 600; letter-spacing:.01em;
      border-radius: clamp(18px,4vw,26px); box-shadow: 0 18px 40px rgba(2,6,23,.45); cursor: pointer;
      transition: transform 160ms ease, box-shadow 160ms ease, background 160ms ease;
      pointer-events: auto; touch-action: manipulation; user-select: none;
    }
    .control-button:active { transform: translateY(2px); box-shadow: 0 8px 24px rgba(2,6,23,.35); }
    .control-button:disabled { opacity:.55; cursor:not-allowed; transform:none; box-shadow: 0 8px 24px rgba(2,6,23,.25); }

    #hold-button {
      bottom: clamp(24px,5vw,48px); right: clamp(24px,5vw,48px);
      padding: clamp(18px,4.8vw,24px) clamp(32px,7vw,48px);
      font-size: clamp(1rem,3vw,1.3rem);
      background: linear-gradient(135deg,#38bdf8,#2563eb);
      color:#f8fafc; min-width: clamp(200px,40vw,320px); text-align:center;
    }
    #hold-button.holding { background: linear-gradient(135deg,#f97316,#ef4444); }

    #stop-experiment {
      top: clamp(24px,5vw,48px); left: clamp(24px,5vw,48px);
      padding: clamp(16px,4vw,20px) clamp(28px,6vw,42px);
      font-size: clamp(.95rem,2.8vw,1.2rem);
      background: rgba(248,250,252,.9); color:#0f172a;
    }

    @media (max-width: 600px) {
      #pre-experiment { padding: 20px; }
      #jspsych-target { padding: clamp(20px,6vw,40px); }
      .stage { border-radius: clamp(20px,8vw,32px); }
    }
  </style>
</head>
<body>
  <div id="pre-experiment">
    <div class="session-card">
      <h1>Resume or explore your JND session</h1>
      <p>
        Upload the JSON file from a previous run to pick up the adaptive staircases where you left off or explore your
        psychometric functions without running a new experiment.
      </p>
      <label class="file-picker">
        <input type="file" id="session-file" accept="application/json" />
        <span>Select JSON file</span>
      </label>
      <p id="session-status" class="session-status" data-state="info">No previous session loaded.</p>

      <div id="calibration-section" class="calibration-section">
        <h2>Calibrate your display</h2>
        <p>
          Pick a familiar object, hold it gently against the screen, and resize the on-screen shape so it matches.
          This lets us convert every pixel on your display into degrees of visual angle.
        </p>
        <p class="small-print">
          Keep the screen at the same distance from your eyes throughout the experiment. If you move, stop and recalibrate before continuing.
        </p>

        <div class="calibration-controls">
          <label for="calibration-object">Reference object</label>
          <select id="calibration-object" disabled>
            <option value="">Loading reference objects…</option>
          </select>
          <div class="calibration-target" id="calibration-target-info"></div>
        </div>

        <div class="calibration-display" id="calibration-display">
          <div class="calibration-instruction">Pinch to zoom or use the slider</div>
          <div class="calibration-shape" id="calibration-shape"></div>
        </div>

        <div class="calibration-slider">
          <input type="range" id="calibration-slider" min="40" max="400" value="200" />
          <span id="calibration-size-readout"></span>
        </div>

        <div class="calibration-controls">
          <label for="viewing-distance">Viewing distance</label>
          <div style="display:flex; align-items:center; gap:8px;">
            <input type="number" id="viewing-distance" inputmode="decimal" min="10" max="200" step="0.5" placeholder="40" />
            <span style="color:rgba(148,163,184,0.9); font-size:0.95em;">cm</span>
          </div>
        </div>

        <button id="calibration-confirm" class="jspsych-btn secondary" type="button">Save calibration</button>
        <p id="calibration-status" class="calibration-status" data-state="info">
          Calibration required before the experiment can begin.
        </p>
      </div>

      <div class="session-actions">
        <button id="start-experiment" class="jspsych-btn" disabled>Calibrate to start</button>
      </div>

      <div id="psychometrics-output" class="psychometrics-output">
        <div style="display:flex; gap:.5rem; align-items:center; margin:.5rem 0; flex-wrap:wrap;">
          <label for="pm-dim">Dimension:</label>
          <select id="pm-dim">
            <option value="theta">θ (angle)</option>
            <option value="radius">radius</option>
          </select>
          <button id="view-psychometrics" class="jspsych-btn" disabled>View my psychometrics</button>
          <span id="pm-status" style="font-size:.9rem;color:#666;"></span>
        </div>
        <canvas id="pm-canvas" width="800" height="420" style="max-width:100%;border:1px solid #eee"></canvas>
      </div>
    </div>
  </div>

  <div id="jspsych-target"></div>
  <button id="stop-experiment" class="control-button" hidden disabled>Stop &amp; Download</button>
  <button id="hold-button" class="control-button" hidden>Hold to Run Trials</button>

  <script src="../jspsych/dist/jspsych.js"></script>
  <script src="../jspsych/plugins/html-button-response.js"></script>
  <script src="../jspsych/plugins/html-keyboard-response.js"></script>
  <script src="../jspsych/plugins/call-function.js"></script>
  <script src="../shared-resources/visual-angle.js"></script>
  <script type="module" src="../shared-resources/calibration.js"></script>

  <script src="https://unpkg.com/jsquest-plus@2.1.0/dist/jsQuestPlus.js"></script>
  <script src="adaptiveQuest.js"></script>
  <script type="module" src="noGoController.js"></script>
  <script> initAdaptiveQuest(); </script>

  <script type="module">
    import {
      init as initCalibration,
      getReference as getCalibrationReference,
      getState as getCalibrationState,
      onReady as onCalibrationReady
    } from '../shared-resources/calibration.js';

    const jsPsych = initJsPsych({ display_element: 'jspsych-target', show_progress_bar: true, auto_update_progress_bar: false });

    const preExperimentOverlay = document.getElementById('pre-experiment');
    const startButton = document.getElementById('start-experiment');
    const fileInput = document.getElementById('session-file');
    const statusEl = document.getElementById('session-status');
    const holdButton = document.getElementById('hold-button');
    const stopExperimentButton = document.getElementById('stop-experiment');
    const calibrationStatusEl = document.getElementById('calibration-status');

    function showCalibrationStatus(message, state = 'info') {
      if (!calibrationStatusEl) return;
      calibrationStatusEl.textContent = message;
      calibrationStatusEl.dataset.state = state;
    }

    initCalibration({
      defaultObjectId: 'credit-card',
      storageKey: 'visual-jnd-calibration',
      startButton,
      elements: {
        section: document.getElementById('calibration-section'),
        objectSelect: document.getElementById('calibration-object'),
        display: document.getElementById('calibration-display'),
        shape: document.getElementById('calibration-shape'),
        slider: document.getElementById('calibration-slider'),
        readout: document.getElementById('calibration-size-readout'),
        status: calibrationStatusEl,
        confirm: document.getElementById('calibration-confirm'),
        viewingDistance: document.getElementById('viewing-distance'),
        target: document.getElementById('calibration-target-info')
      }
    }).catch(error => {
      console.error('Calibration initialization failed', error);
      showCalibrationStatus('Calibration could not be initialised. Please reload the page.', 'error');
    });

    const calibrationState = getCalibrationState();
    function getVisualReference() { return getCalibrationReference(); }

    onCalibrationReady(() => { updateDerivedDvaMetrics(); });
    window.addEventListener('visual-calibration-cleared', () => { updateDerivedDvaMetrics(); });

    const TOTAL_TRIALS = 1000;
    const FIRST_STIM_DURATION = 59;
    const SECOND_STIM_DURATION = 59;
    const RESPONSE_WINDOW = 1400;

    const FIXATION_DIAMETER_DVA = 0.12;
    const TARGET_DIAMETER_DVA = 0.12;
    const MAX_TARGET_ECCENTRICITY_DVA = 3.0;

    let DOT_DIAMETER = 30;
    let FIXATION_DIAMETER_PX = 6;

    let uploadedDataArray = [];
    let previousTrialCount = 0;
    let progressBase = 0;
    let progressTotal = TOTAL_TRIALS;
    let sessionRunning = false;
    let sessionFinalized = false;
    let lastHoldStartTime = null;

    window.JND_SESSION = { trials: [] };
    function broadcastSessionUpdate() {
      const trials = Array.isArray(uploadedDataArray) ? [...uploadedDataArray] : [];
      window.JND_SESSION = { trials };
      window.dispatchEvent(new Event('jnd-session-loaded'));
    }

    const stageSide = Math.min(window.innerWidth, window.innerHeight) * 0.7;
    document.documentElement.style.setProperty('--stage-size', `${Math.round(stageSide)}px`);
    const stageCenter = stageSide / 2;
    const stagePadding = Math.max(28, stageSide * 0.06);
    const maxRadius = Math.max(90, stageCenter - stagePadding);

    let minRadiusDva = null, maxRadiusDva = null, dotDiameterDva = null;

    function updateDerivedDvaMetrics() {
      const reference = getVisualReference();
      if (!reference || typeof VisualAngle === 'undefined') {
        minRadiusDva = null; maxRadiusDva = null; dotDiameterDva = null;
        DOT_DIAMETER = 30; FIXATION_DIAMETER_PX = 6; return;
      }
      try {
        DOT_DIAMETER = Math.max(2, Math.round(VisualAngle.dvaToPixels(TARGET_DIAMETER_DVA, reference)));
        FIXATION_DIAMETER_PX = Math.max(2, Math.round(VisualAngle.dvaToPixels(FIXATION_DIAMETER_DVA, reference)));
        minRadiusDva = 0;
        maxRadiusDva = MAX_TARGET_ECCENTRICITY_DVA;
        dotDiameterDva = VisualAngle.pixelsToDVA(DOT_DIAMETER, reference);
      } catch (error) {
        console.warn('Failed to derive DVA metrics', error);
        minRadiusDva = null; maxRadiusDva = null; dotDiameterDva = null;
        DOT_DIAMETER = 30; FIXATION_DIAMETER_PX = 6;
      }
    }
    updateDerivedDvaMetrics();

    function updateHoldButton(isActive) {
      if (!holdButton) return;
      holdButton.classList.toggle('holding', Boolean(isActive));
      holdButton.setAttribute('aria-pressed', isActive ? 'true' : 'false');
      holdButton.textContent = isActive ? 'Release to Report Change' : 'Hold to Run Trials';
    }
    function updateStopButtonState() {
      if (!stopExperimentButton) return;
      if (!sessionRunning) { stopExperimentButton.disabled = true; return; }
      stopExperimentButton.disabled = holdState.isActive();
    }

    const holdState = {
      sources: new Map(), holdStart: null, primarySource: 'none',
      holdStartListeners: new Set(), releaseListeners: new Set(), lastReleaseInfo: null,
      activate(key, source='pointer') {
        if (this.sources.has(key)) return;
        const now = performance.now();
        this.sources.set(key, { source, startedAt: now });
        if (this.sources.size === 1) {
          this.holdStart = now; this.primarySource = source; this.lastReleaseInfo = null;
          updateHoldButton(true); updateStopButtonState();
          Array.from(this.holdStartListeners).forEach(fn => { try { fn({ source, startedAt: now }); } catch {} });
        }
      },
      release(key, source='pointer') {
        if (!this.sources.has(key)) return;
        this.sources.delete(key);
        if (this.sources.size === 0) {
          const now = performance.now();
          const startedAt = this.holdStart;
          const info = { source: source || this.primarySource || 'none', duration: (typeof startedAt==='number'? now-startedAt:null), startedAt: (typeof startedAt==='number'? startedAt:null), releasedAt: now };
          this.holdStart = null; this.primarySource = 'none'; this.lastReleaseInfo = info;
          updateHoldButton(false); updateStopButtonState();
          Array.from(this.releaseListeners).forEach(fn => { try { fn(info); } catch {} });
        }
      },
      isActive() { return this.sources.size > 0; },
      reset() {
        this.sources.clear(); this.holdStart=null; this.primarySource='none';
        this.holdStartListeners.clear(); this.releaseListeners.clear();
        this.lastReleaseInfo = null; updateHoldButton(false); updateStopButtonState();
      }
    };

    updateHoldButton(false); updateStopButtonState();

    const HOLD_KEY = 'keyboard-space';
    if (holdButton) {
      holdButton.addEventListener('pointerdown', e => {
        if (!sessionRunning) return;
        e.preventDefault();
        try { holdButton.setPointerCapture(e.pointerId); } catch {}
        holdState.activate(`pointer-${e.pointerId}`, 'pointer');
      });
      const releasePointer = e => { try { holdButton.releasePointerCapture(e.pointerId); } catch {} holdState.release(`pointer-${e.pointerId}`, 'pointer'); };
      holdButton.addEventListener('pointerup', releasePointer);
      holdButton.addEventListener('pointercancel', releasePointer);
      holdButton.addEventListener('lostpointercapture', releasePointer);
    }
    document.addEventListener('keydown', e => {
      if (!sessionRunning) return;
      if (e.code==='Space' || e.key===' ') { if (e.repeat) return; e.preventDefault(); holdState.activate(HOLD_KEY,'keyboard'); }
    });
    document.addEventListener('keyup', e => { if (e.code==='Space'||e.key===' ') { e.preventDefault(); holdState.release(HOLD_KEY,'keyboard'); } });

    function clamp(v, lo, hi) { return Math.min(hi, Math.max(lo, v)); }
    function setStatus(msg, state='info') { if (!statusEl) return; statusEl.textContent = msg; statusEl.dataset.state = state; }
    const degToRad = deg => (deg * Math.PI) / 180;
    const wrapAngle = t => ((t % (2*Math.PI)) + 2*Math.PI) % (2*Math.PI);
    function polarToCartesian(cx, cy, r, th) { return { x: cx + r*Math.cos(th), y: cy + r*Math.sin(th) }; }

    // Uniform in area within 3° disk
    function samplePointInDiskDeg(rMaxDeg = MAX_TARGET_ECCENTRICITY_DVA) {
      const u = Math.random();
      const r = Math.sqrt(u) * rMaxDeg;
      const th = Math.random() * 2 * Math.PI;
      return { xDeg: r * Math.cos(th), yDeg: r * Math.sin(th), rDeg: r, thRad: th };
    }

    let trialState = {};

    const instructions = {
      type: jsPsychHtmlButtonResponse,
      stimulus: () => {
        const continuation = previousTrialCount
          ? `<p style="color: rgba(148, 163, 184, 0.88);">Continuing from trial ${previousTrialCount + 1} with your uploaded staircases.</p>`
          : '';
        let dotInfo = '';
        let eccInfo = '';
        if (Number.isFinite(dotDiameterDva)) dotInfo = ` (~${dotDiameterDva.toFixed(2)}° visual angle)`;
        if (Number.isFinite(minRadiusDva) && Number.isFinite(maxRadiusDva)) {
          eccInfo = `Your calibrated eccentricities span roughly ${minRadiusDva.toFixed(2)}°–${maxRadiusDva.toFixed(2)}° from fixation.`;
        }
        const eccInfoText = eccInfo ? `${eccInfo} ` : '';
        return `
          <h1 style="margin-top:0">Just Noticeable Difference (Go/No-Go)</h1>
          <p>A white dot will flash twice while you maintain fixation on the central black spot.
             After a random blank interval (100–1500&nbsp;ms) the dot reappears for comparison.
          </p>
          <p>On most trials the dot is identical (<strong>no-go</strong>). About one third of the time
             it shifts slightly in angle or radius (<strong>go</strong> trials). Each flash lasts
             about ${FIRST_STIM_DURATION}&nbsp;ms and shares the same ${DOT_DIAMETER}&nbsp;px diameter${dotInfo}.
             Targets are sampled uniformly within a ${MAX_TARGET_ECCENTRICITY_DVA.toFixed(1)}° radius when calibrated.
          </p>
          <ul>
            <li>Hold the glowing control button (or spacebar) to run trials.</li>
            <li>Release as soon as the comparison differs from the reference.</li>
            <li>If identical, keep holding to start the next trial immediately.</li>
          </ul>
          <p>${eccInfoText}Keep the screen at the calibrated distance; if posture changes, recalibrate before resuming.</p>
          ${continuation}
        `;
      },
      choices: ['Begin']
    };

    function createTrial(index, offset=0) {
      let holdGateListener = null;
      const waitForHold = {
        type: jsPsychCallFunction, async: true, data: { stage: 'hold_gate', trial_index: offset + index + 1 },
        func: callback => {
          const resolve = startedAt => {
            if (holdGateListener) { holdState.holdStartListeners.delete(holdGateListener); holdGateListener = null; }
            lastHoldStartTime = typeof startedAt === 'number' ? startedAt : performance.now();
            callback({ startedAt: lastHoldStartTime });
          };
          if (holdState.isActive()) { resolve(holdState.holdStart); return; }
          const d = jsPsych.getDisplayElement(); if (d) d.innerHTML = stageHTML('<div class="response-text">Hold the control button or spacebar to begin the next trial.</div>');
          holdGateListener = info => resolve(typeof info?.startedAt === 'number' ? info.startedAt : holdState.holdStart);
          holdState.holdStartListeners.add(holdGateListener);
        },
        on_finish: data => {
          if (holdGateListener) { holdState.holdStartListeners.delete(holdGateListener); holdGateListener = null; }
          const info = data.value || {};
          if (typeof info.startedAt === 'number') lastHoldStartTime = info.startedAt;
          else if (typeof holdState.holdStart === 'number') lastHoldStartTime = holdState.holdStart;
          else lastHoldStartTime = performance.now();
        }
      };

      const setup = {
        type: jsPsychCallFunction,
        func: () => {
          const total = Math.max(progressTotal, 1);
          jsPsych.setProgressBar((progressBase + index) / total);

          const reference = getVisualReference();
          const ctrl = (typeof NoGoCtrl !== 'undefined') ? NoGoCtrl : null;
          const isNoGo = ctrl && typeof ctrl.decideNoGo === 'function' ? ctrl.decideNoGo() : false;

          trialState = {
            index: offset + index + 1,
            isNoGo, isGo: !isNoGo,
            isi: jsPsych.randomization.randomInt(100, 1500),
            changeType: 'none',
            questStimValue: null, questContext: null,
            deltaTheta: 0, deltaRadius: 0, deltaDiameter: 0,
            holdStartedAt: lastHoldStartTime,
            visualReference: reference || null,
            mmPerPixel: reference?.mmPerPixel ?? null,
            viewingDistanceMm: reference?.viewingDistanceMm ?? null,
            baseRadiusDva: null, secondRadiusDva: null,
            baseDiameterDva: null, secondDiameterDva: null,
            deltaRadiusDva: null, deltaDiameterDva: null,
            dotColor: null, maxRadiusPx: null, maxRadiusDva: null
          };

          // Sample S1 in 3° disk (uniform area)
          const sampled = samplePointInDiskDeg(MAX_TARGET_ECCENTRICITY_DVA);
          let baseTheta = sampled.thRad;
          let baseRadius = 0;
          let radiusLimit = maxRadius;
          const referenceReady = Boolean(reference && typeof VisualAngle !== 'undefined');
          if (referenceReady) {
            try {
              const pxLimit = VisualAngle.dvaToPixels(MAX_TARGET_ECCENTRICITY_DVA, reference);
              if (Number.isFinite(pxLimit) && pxLimit > 0) radiusLimit = pxLimit;
              const pxRadius = VisualAngle.dvaToPixels(sampled.rDeg, reference);
              if (Number.isFinite(pxRadius)) baseRadius = pxRadius;
            } catch (e) { console.warn('Fallback to px-based sampling', e); }
          }
          if (!Number.isFinite(radiusLimit) || radiusLimit <= 0) radiusLimit = Math.max(120, maxRadius);
          if (!Number.isFinite(baseRadius)) {
            const scale = MAX_TARGET_ECCENTRICITY_DVA > 0 ? sampled.rDeg / MAX_TARGET_ECCENTRICITY_DVA : 0;
            baseRadius = scale * radiusLimit;
          }
          baseRadius = clamp(baseRadius, 0, radiusLimit);
          trialState.maxRadiusPx = radiusLimit;

          const baseDiameter = DOT_DIAMETER;
          let secondTheta = baseTheta, secondRadius = baseRadius, secondDiameter = DOT_DIAMETER;

          if (trialState.isGo) {
            const selected = jsPsych.randomization.sampleWithoutReplacement(['theta', 'radius'], 1)[0];
            trialState.changeType = selected;

            const eccDva = reference && typeof VisualAngle !== 'undefined'
              ? VisualAngle.pixelsToDVA(baseRadius, reference) : null;

            const ctx = { changeType: selected, soaMs: trialState.isi, eccPx: baseRadius, eccDva, thetaRad: baseTheta };
            const stim = suggestDeltaForContext(ctx);
            trialState.questStimValue = stim;
            trialState.questContext = ctx;

            if (selected === 'theta') {
              trialState.deltaTheta = stim;
              const dir = jsPsych.randomization.sampleWithoutReplacement([-1, 1], 1)[0];
              secondTheta = wrapAngle(baseTheta + dir * degToRad(stim));
            } else {
              trialState.deltaRadius = stim;
              const dir = jsPsych.randomization.sampleWithoutReplacement([-1, 1], 1)[0];
              secondRadius = clamp(baseRadius + dir * stim, 0, radiusLimit);
            }
          }

          const firstCoords = polarToCartesian(stageCenter, stageCenter, baseRadius, baseTheta);
          const secondCoords = polarToCartesian(stageCenter, stageCenter, secondRadius, secondTheta);

          Object.assign(trialState, {
            baseTheta, baseRadius, baseDiameter,
            secondTheta, secondRadius, secondDiameter,
            firstX: firstCoords.x, firstY: firstCoords.y,
            secondX: secondCoords.x, secondY: secondCoords.y
          });

          if (reference && typeof VisualAngle !== 'undefined') {
            try {
              trialState.baseRadiusDva   = VisualAngle.pixelsToDVA(baseRadius, reference);
              trialState.secondRadiusDva = VisualAngle.pixelsToDVA(secondRadius, reference);
              trialState.baseDiameterDva = VisualAngle.pixelsToDVA(baseDiameter, reference);
              trialState.secondDiameterDva = VisualAngle.pixelsToDVA(secondDiameter, reference);
              trialState.deltaRadiusDva  = VisualAngle.pixelsToDVA(Math.abs(trialState.deltaRadius), reference);
              trialState.deltaDiameterDva= VisualAngle.pixelsToDVA(Math.abs(trialState.deltaDiameter), reference);
              trialState.maxRadiusDva    = VisualAngle.pixelsToDVA(trialState.maxRadiusPx, reference);
            } catch (e) {
              trialState.baseRadiusDva = trialState.secondRadiusDva = trialState.baseDiameterDva = trialState.secondDiameterDva = null;
              trialState.deltaRadiusDva = trialState.deltaDiameterDva = trialState.maxRadiusDva = null;
            }
          }
          if (trialState.questContext) {
            trialState.questContext.eccDva = trialState.baseRadiusDva;
            trialState.questContext.mmPerPixel = calibrationState.ready ? calibrationState.mmPerPixel : null;
          }
        }
      };

      const fixation = { type: jsPsychHtmlKeyboardResponse, stimulus: () => stageHTML('', { showFixation: true }), choices: 'NO_KEYS', trial_duration: () => jsPsych.randomization.randomInt(500, 1000), data: { stage: 'fixation' } };
      const firstStim = { type: jsPsychHtmlKeyboardResponse, stimulus: () => stageHTML(dotHTML(trialState.firstX, trialState.firstY, trialState.baseDiameter), { showFixation: true }), choices: 'NO_KEYS', trial_duration: FIRST_STIM_DURATION, data: { stage: 'stimulus_1', trial_index: trialState.index } };
      const isi = { type: jsPsychHtmlKeyboardResponse, stimulus: () => stageHTML('', { showFixation: true }), choices: 'NO_KEYS', trial_duration: () => trialState.isi, data: { stage: 'isi' } };

      const secondStim = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: () => stageHTML(dotHTML(trialState.secondX, trialState.secondY, trialState.secondDiameter), { showFixation: false }),
        choices: 'NO_KEYS', trial_duration: SECOND_STIM_DURATION,
        on_load: () => { trialState.secondStimOnset = performance.now(); },
        data: { stage: 'stimulus_2', trial_index: trialState.index }
      };

      const response = {
        type: jsPsychCallFunction, async: true, data: { stage: 'response' },
        func: callback => {
          const d = jsPsych.getDisplayElement(); if (d) d.innerHTML = stageHTML();
          const responseStart = performance.now();
          let finished = false, timerId = null, reappearTimer = null, fixationRestored = false;
          const baselineOnset = (typeof trialState.secondStimOnset === 'number' ? trialState.secondStimOnset : responseStart);

          const scheduleFixationReturn = delay => {
            if (delay <= 0) {
              if (!fixationRestored) { const el = jsPsych.getDisplayElement(); if (el) el.innerHTML = stageHTML('', { showFixation: true }); fixationRestored = true; }
              return null;
            }
            return window.setTimeout(() => {
              if (!fixationRestored) { const el = jsPsych.getDisplayElement(); if (el) el.innerHTML = stageHTML('', { showFixation: true }); fixationRestored = true; }
              reappearTimer = null;
            }, delay);
          };
          reappearTimer = scheduleFixationReturn(Math.max(0, 500 - (performance.now() - baselineOnset)));

          const finish = result => {
            if (finished) return; finished = true;
            if (result) holdState.lastReleaseInfo = null;
            if (timerId !== null) window.clearTimeout(timerId);
            const remaining = Math.max(0, 500 - (performance.now() - baselineOnset));
            if (reappearTimer !== null) { window.clearTimeout(reappearTimer); reappearTimer = scheduleFixationReturn(remaining); }
            else if (!fixationRestored) { reappearTimer = scheduleFixationReturn(remaining); }
            if (trialState.releaseListener) { holdState.releaseListeners.delete(trialState.releaseListener); trialState.releaseListener = null; }
            callback(result);
          };

          const handleRelease = info => {
            const hs = (typeof info?.startedAt === 'number' ? info.startedAt :
                       typeof trialState.holdStartedAt === 'number' ? trialState.holdStartedAt :
                       typeof holdState.holdStart === 'number' ? holdState.holdStart : lastHoldStartTime);
            const hr = typeof info?.releasedAt === 'number' ? info.releasedAt : performance.now();
            const dur = typeof info?.duration === 'number' ? info.duration :
                        (hs != null && hr != null ? hr - hs : null);
            finish({ responded: true, response_source: info?.source || holdState.primarySource || 'none', rt: performance.now() - responseStart, hold_started_at: hs ?? null, hold_released_at: hr ?? null, hold_duration: dur ?? null });
          };

          trialState.releaseListener = handleRelease;
          holdState.releaseListeners.add(handleRelease);

          const cached = holdState.lastReleaseInfo;
          if (cached && typeof cached.releasedAt === 'number' && typeof trialState.secondStimOnset === 'number' && cached.releasedAt >= trialState.secondStimOnset) {
            handleRelease(cached);
          }

          if (finished) return;
          timerId = window.setTimeout(() => {
            const hs = typeof trialState.holdStartedAt === 'number' ? trialState.holdStartedAt : (typeof holdState.holdStart === 'number' ? holdState.holdStart : lastHoldStartTime);
            const dur = (hs != null ? performance.now() - hs : null);
            finish({ responded: false, response_source: 'none', rt: null, hold_started_at: hs ?? null, hold_released_at: null, hold_duration: dur });
          }, RESPONSE_WINDOW);
        },
        on_finish: data => {
          if (trialState.releaseListener) { holdState.releaseListeners.delete(trialState.releaseListener); trialState.releaseListener = null; }
          const result = data.value || {};
          const responded = result.responded === true;
          const rt = typeof result.rt === 'number' ? result.rt : null;
          const hs = typeof result.hold_started_at === 'number' ? result.hold_started_at :
                     typeof trialState.holdStartedAt === 'number' ? trialState.holdStartedAt : lastHoldStartTime;
          const hr = typeof result.hold_released_at === 'number' ? result.hold_released_at :
                     (responded && typeof hs === 'number' ? hs + (typeof result.hold_duration === 'number' ? result.hold_duration : rt ?? 0) : null);
          const dur = typeof result.hold_duration === 'number' ? result.hold_duration :
                      (hr != null && hs != null ? hr - hs : null);
          const source = responded ? (result.response_source || holdState.primarySource || 'none') : 'none';

          const ctrl = (typeof NoGoCtrl !== 'undefined') ? NoGoCtrl : null;
          if (ctrl && typeof ctrl.onTrialEnd === 'function') ctrl.onTrialEnd({ isNoGo: trialState.isNoGo === true, responded });

          Object.assign(data, {
            rt, response_source: source,
            is_go: trialState.isGo, is_no_go: trialState.isNoGo,
            change_type: trialState.changeType,
            delta_theta: trialState.deltaTheta, delta_radius: trialState.deltaRadius, delta_diameter: trialState.deltaDiameter,
            delta_radius_dva: trialState.deltaRadiusDva, delta_diameter_dva: trialState.deltaDiameterDva,
            first_theta: trialState.baseTheta, first_radius: trialState.baseRadius, first_diameter: trialState.baseDiameter,
            first_radius_dva: trialState.baseRadiusDva, first_diameter_dva: trialState.baseDiameterDva,
            second_theta: trialState.secondTheta, second_radius: trialState.secondRadius, second_diameter: trialState.secondDiameter,
            second_radius_dva: trialState.secondRadiusDva, second_diameter_dva: trialState.secondDiameterDva,
            second_onset: typeof trialState.secondStimOnset === 'number' ? trialState.secondStimOnset : null,
            dot_color: trialState.dotColor?.fill ?? null,
            first_stim_duration: FIRST_STIM_DURATION, second_stim_duration: SECOND_STIM_DURATION,
            fixation_reappear_delay: 500,
            fixation_diameter_px: FIXATION_DIAMETER_PX, fixation_diameter_dva: FIXATION_DIAMETER_DVA,
            target_diameter_px: DOT_DIAMETER, target_diameter_dva: TARGET_DIAMETER_DVA,
            max_radius_px: trialState.maxRadiusPx, max_radius_dva: trialState.maxRadiusDva,
            max_target_eccentricity_dva: MAX_TARGET_ECCENTRICITY_DVA,
            interstimulus: trialState.isi, trial_number: trialState.index,
            go_success: trialState.isGo ? responded : null,
            correct: trialState.isGo ? responded : !responded,
            quest_value: trialState.questStimValue,
            calibration_mm_per_pixel: trialState.mmPerPixel ?? (calibrationState.ready ? calibrationState.mmPerPixel : null),
            calibration_viewing_distance_mm: trialState.viewingDistanceMm ?? (calibrationState.ready ? calibrationState.viewingDistanceMm : null),
            calibration_dva_per_pixel: calibrationState.ready ? calibrationState.dvaPerPixel : null,
            calibration_object_id: calibrationState.ready ? calibrationState.objectId : null,
            hold_started_at: typeof hs === 'number' ? hs : null, hold_released_at: typeof hr === 'number' ? hr : null, hold_duration: typeof dur === 'number' ? dur : null,
            responded
          });

          trialState.holdStartedAt = data.hold_started_at;

          if (trialState.isGo && typeof trialState.questStimValue === 'number' && trialState.questContext) {
            const responseIndex = responded ? 1 : 0;
            try { updateQuestWithOutcome(trialState.questContext, trialState.questStimValue, responseIndex); } catch {}
          }
        }
      };

      return [waitForHold, setup, fixation, firstStim, isi, secondStim, response];
    }

    const sessionComplete = { type: jsPsychCallFunction, data: { stage: 'session_complete' }, func: () => { finalizeSession('complete'); return { stage: 'session_complete' }; } };

    function buildTimeline(offset=0) {
      const timeline = [instructions];
      for (let i=0;i<TOTAL_TRIALS;i++) timeline.push(...createTrial(i, offset));
      timeline.push(sessionComplete);
      return timeline;
    }

    function finalizeSession(reason='complete') {
      if (sessionFinalized) return;
      sessionFinalized = true; sessionRunning = false; lastHoldStartTime = null; holdState.reset(); updateStopButtonState();
      if (holdButton) { holdButton.hidden = true; }
      if (stopExperimentButton) { stopExperimentButton.hidden = true; stopExperimentButton.disabled = true; }
      jsPsych.setProgressBar(1);

      const newValues = jsPsych.data.get().values();
      const combined = uploadedDataArray.length ? [...uploadedDataArray, ...newValues] : [...newValues];
      const ts = new Date().toISOString().replace(/[:.]/g,'-');
      if (newValues.length) {
        const blob = (content, name, type) => { const b=new Blob([content],{type}); const url=URL.createObjectURL(b); const a=document.createElement('a'); a.href=url; a.download=name; a.rel='noopener'; document.body.appendChild(a); a.click(); document.body.removeChild(a); setTimeout(()=>URL.revokeObjectURL(url),0); };
        blob(JSON.stringify(combined,null,2), `jnd-go-nogo-${ts}.json`, 'application/json');
        blob(jsPsych.data.get().csv(), `jnd-go-nogo-${ts}.csv`, 'text/csv');
      }
      uploadedDataArray = combined;
      seedQuestsFromData(uploadedDataArray);
      progressBase = previousTrialCount; progressTotal = previousTrialCount + TOTAL_TRIALS;
      broadcastSessionUpdate();
      if (startButton) startButton.textContent = uploadedDataArray.length ? 'Run another block' : 'Start experiment';
      setStatus(newValues.length ? `${reason === 'stopped' ? 'Session stopped early.' : 'Session complete.'} Downloaded ${newValues.length} new trials.` : `${reason === 'stopped' ? 'Session stopped.' : 'Session ended.'} No new trials were recorded.`, 'info');
      if (preExperimentOverlay) preExperimentOverlay.classList.remove('hidden');
      jsPsych.getDisplayElement().innerHTML = '';
    }

    function startExperiment() {
      progressBase = previousTrialCount;
      progressTotal = previousTrialCount + TOTAL_TRIALS;
      const timeline = buildTimeline(previousTrialCount);
      sessionRunning = true; sessionFinalized = false; lastHoldStartTime = null; holdState.reset();
      if (holdButton) holdButton.hidden = false;
      if (stopExperimentButton) { stopExperimentButton.hidden = false; stopExperimentButton.disabled = false; }
      updateStopButtonState();
      if (preExperimentOverlay) preExperimentOverlay.classList.add('hidden');
      jsPsych.run(timeline);
    }

    if (startButton) {
      startButton.addEventListener('click', () => {
        if (!calibrationState.ready) {
          showCalibrationStatus('Please complete and save the calibration before starting.', 'error');
          setStatus('Calibration required before starting the experiment.', 'warning');
          return;
        }
        startExperiment();
      });
    }

    if (stopExperimentButton) {
      stopExperimentButton.addEventListener('click', () => {
        if (stopExperimentButton.disabled) return;
        finalizeSession('stopped');
        jsPsych.endExperiment('');
      });
    }

    function seedQuestsFromData(arr) {
      initAdaptiveQuest();
      previousTrialCount = 0;
      if (!Array.isArray(arr)) return;
      arr.forEach(t => {
        if (!t || t.stage !== 'response') return;
        const n = Number(t.trial_number ?? t.trialIndex ?? t.trial_index);
        if (Number.isFinite(n)) previousTrialCount = Math.max(previousTrialCount, n);
      });
    }

    if (fileInput) {
      fileInput.addEventListener('change', evt => {
        const files = evt.target.files || [];
        const file = files[0];
        if (!file) {
          uploadedDataArray = []; previousTrialCount = 0;
          initAdaptiveQuest(); progressBase = 0; progressTotal = TOTAL_TRIALS;
          broadcastSessionUpdate();
          if (startButton) startButton.textContent = 'Start experiment';
          setStatus('No previous session loaded.', 'info');
          return;
        }
        const reader = new FileReader();
        reader.onload = e => {
          try {
            const raw = JSON.parse(e.target.result);
            const normalised = Array.isArray(raw) ? raw : Array.isArray(raw.data) ? raw.data : Array.isArray(raw.trials) ? raw.trials : [];
            if (!Array.isArray(normalised)) throw new Error('Invalid JSON structure');
            uploadedDataArray = normalised.filter(x => x && typeof x === 'object');
            seedQuestsFromData(uploadedDataArray);
            progressBase = previousTrialCount; progressTotal = previousTrialCount + TOTAL_TRIALS;
            broadcastSessionUpdate();
            const rc = uploadedDataArray.filter(tr => tr && tr.stage === 'response').length;
            let msg = `Loaded ${uploadedDataArray.length} trials from ${file.name}.`;
            if (previousTrialCount) msg += ` Continuing from trial ${previousTrialCount + 1}.`;
            if (rc) msg += ` ${rc} response-stage records detected.`;
            setStatus(msg, 'info');
            if (startButton) startButton.textContent = uploadedDataArray.length ? 'Continue experiment' : 'Start experiment';
          } catch (err) {
            console.error(err);
            uploadedDataArray = []; previousTrialCount = 0; initAdaptiveQuest(); progressBase = 0; progressTotal = TOTAL_TRIALS;
            broadcastSessionUpdate();
            if (startButton) startButton.textContent = 'Start experiment';
            setStatus('Could not parse that JSON file. Please ensure it was exported from this experiment.', 'error');
          } finally {
            fileInput.value = '';
          }
        };
        reader.onerror = () => {
          uploadedDataArray = []; previousTrialCount = 0; initAdaptiveQuest(); progressBase = 0; progressTotal = TOTAL_TRIALS;
          broadcastSessionUpdate();
          if (startButton) startButton.textContent = 'Start experiment';
          setStatus('Unable to read the selected file.', 'error');
          fileInput.value = '';
        };
        reader.readAsText(file);
      });
    }

    setStatus('No previous session loaded.', 'info');

    // helpers used earlier
    function stageHTML(content = '', { showFixation = false } = {}) {
      const fixation = showFixation ? `<div class="fixation-dot" style="width:${FIXATION_DIAMETER_PX}px;height:${FIXATION_DIAMETER_PX}px;"></div>` : '';
      return `<div class="stage">${fixation}${content}</div>`;
    }
    function dotHTML(x, y, diameter = DOT_DIAMETER) {
      return `<div class="dot" style="left:${x}px;top:${y}px;width:${diameter}px;height:${diameter}px;"></div>`;
    }
  </script>
</body>
</html>
