<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Just Noticeable Difference Go/No-Go</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="../jspsych/css/jspsych.css" />
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Inter", "Helvetica Neue", Arial, sans-serif;
      --bg: radial-gradient(circle at top, #0f172a 0%, #111827 60%, #020617 100%);
      --card-bg: rgba(15, 23, 42, 0.9);
      --accent: #38bdf8;
      --stage-size: min(68vw, 68vh);
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg);
      color: #e2e8f0;
      padding: clamp(16px, 4vw, 48px);
    }

    #pre-experiment {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.96) 0%, rgba(2, 6, 23, 0.94) 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: clamp(24px, 6vw, 72px);
      z-index: 10;
      transition: opacity 220ms ease;
    }

    #pre-experiment.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .session-card {
      width: min(92vw, 720px);
      background: rgba(15, 23, 42, 0.85);
      border-radius: clamp(24px, 4vw, 36px);
      box-shadow: 0 30px 70px rgba(2, 6, 23, 0.6);
      padding: clamp(28px, 6vw, 56px);
      display: flex;
      flex-direction: column;
      gap: clamp(16px, 4vw, 28px);
    }

    .session-card h1 {
      margin: 0;
      font-size: clamp(1.6rem, 4vw, 2.15rem);
    }

    .session-card p {
      margin: 0;
      color: rgba(203, 213, 225, 0.92);
    }

    .file-picker {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 999px;
      padding: 0;
      overflow: hidden;
      width: fit-content;
      background: rgba(148, 163, 184, 0.12);
      border: 1px solid rgba(148, 163, 184, 0.18);
      cursor: pointer;
    }

    .file-picker input[type='file'] {
      position: absolute;
      inset: 0;
      opacity: 0;
      cursor: pointer;
    }

    .file-picker span {
      padding: 12px 24px;
      font-weight: 600;
      color: #e2e8f0;
      font-size: clamp(0.95rem, 2.4vw, 1.05rem);
    }

    .session-status {
      margin: 0;
      font-size: clamp(0.95rem, 2.6vw, 1.05rem);
      color: rgba(148, 163, 184, 0.88);
    }

    .session-status[data-state='error'] {
      color: #fca5a5;
    }

    .session-status[data-state='warning'] {
      color: #facc15;
    }

    .session-status strong {
      color: #f8fafc;
    }

    .session-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
    }

    .session-actions .jspsych-btn:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }

    .psychometrics-output {
      border-top: 1px solid rgba(148, 163, 184, 0.18);
      padding-top: clamp(16px, 4vw, 28px);
      display: flex;
      flex-direction: column;
      gap: clamp(16px, 4vw, 24px);
    }

    .psychometrics-output[hidden] {
      display: none;
    }

    .psych-section {
      background: rgba(15, 23, 42, 0.65);
      border-radius: clamp(16px, 4vw, 24px);
      padding: clamp(16px, 4vw, 24px);
      border: 1px solid rgba(148, 163, 184, 0.18);
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .psych-section h3 {
      margin: 0;
      font-size: clamp(1.1rem, 3vw, 1.35rem);
    }

    .psych-section p {
      margin: 0;
      color: rgba(226, 232, 240, 0.82);
    }

    .psych-section canvas {
      width: 100%;
      min-height: 220px;
    }

    #jspsych-target {
      width: min(96vw, 860px);
      background: rgba(15, 23, 42, 0.82);
      backdrop-filter: blur(18px);
      border-radius: 32px;
      box-shadow: 0 24px 60px rgba(2, 6, 23, 0.55);
      padding: clamp(24px, 5vw, 56px);
    }

    .jspsych-display-element {
      font-size: clamp(18px, 3vw, 22px);
      line-height: 1.7;
    }

    .jspsych-btn {
      font-size: clamp(1rem, 2.6vw, 1.15rem);
      padding: clamp(12px, 3vw, 16px) clamp(24px, 5vw, 36px);
      border-radius: 999px;
      border: none;
      background: linear-gradient(135deg, var(--accent), #2563eb);
      color: white;
      font-weight: 600;
      box-shadow: inset 0 -2px 0 rgba(15, 23, 42, 0.25);
      transition: transform 160ms ease, box-shadow 160ms ease;
      touch-action: manipulation;
    }

    .jspsych-btn:active {
      transform: translateY(2px);
      box-shadow: inset 0 2px 0 rgba(15, 23, 42, 0.35);
    }

    .stage {
      position: relative;
      width: var(--stage-size);
      height: var(--stage-size);
      margin: 0 auto;
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.95) 0%, rgba(2, 6, 23, 0.88) 80%);
      border-radius: clamp(24px, 6vw, 36px);
      box-shadow: inset 0 0 0 2px rgba(148, 163, 184, 0.08), 0 24px 60px rgba(2, 6, 23, 0.6);
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .dot {
      position: absolute;
      left: 50%;
      top: 50%;
      border-radius: 999px;
      background: #f8fafc;
      box-shadow: 0 0 20px rgba(248, 250, 252, 0.65);
      transform: translate(-50%, -50%);
      will-change: transform;
    }

    .fixation {
      font-size: clamp(36px, 7vw, 64px);
      font-weight: 600;
      color: rgba(241, 245, 249, 0.85);
      text-shadow: 0 8px 30px rgba(15, 23, 42, 0.7);
    }

    .response-text {
      font-size: clamp(18px, 3.2vw, 24px);
      color: rgba(226, 232, 240, 0.94);
      text-align: center;
      padding: 24px;
    }

    .trial-progress {
      font-size: clamp(14px, 2.5vw, 16px);
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(148, 163, 184, 0.8);
      text-align: center;
      margin-bottom: 16px;
    }

    #hold-control,
    #stop-control {
      position: fixed;
      z-index: 30;
      border: none;
      border-radius: clamp(18px, 5vw, 28px);
      font-weight: 600;
      font-size: clamp(0.95rem, 2.4vw, 1.15rem);
      padding: clamp(16px, 4vw, 22px) clamp(28px, 6vw, 38px);
      color: #0f172a;
      background: linear-gradient(135deg, #f8fafc, #e2e8f0);
      box-shadow: 0 24px 40px rgba(2, 6, 23, 0.35);
      cursor: pointer;
      touch-action: none;
      transition: transform 180ms ease, box-shadow 180ms ease, opacity 180ms ease;
    }

    #hold-control {
      bottom: clamp(16px, 4vw, 40px);
      right: clamp(16px, 4vw, 40px);
      background: linear-gradient(135deg, #34d399, #10b981);
      color: #022c22;
    }

    #hold-control[data-state='active'] {
      transform: translateY(1px);
      box-shadow: inset 0 2px 0 rgba(2, 6, 23, 0.25);
    }

    #stop-control {
      top: clamp(16px, 4vw, 40px);
      left: clamp(16px, 4vw, 40px);
      background: linear-gradient(135deg, #f87171, #ef4444);
      color: #fee2e2;
    }

    #stop-control:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
    }

    @media (max-width: 600px) {
      #pre-experiment {
        padding: 20px;
      }

      #jspsych-target {
        padding: clamp(20px, 6vw, 40px);
      }

      .stage {
        border-radius: clamp(20px, 8vw, 32px);
      }
    }
  </style>
</head>
<body>
  <div id="pre-experiment">
    <div class="session-card">
      <h1>Resume or explore your JND session</h1>
      <p>
        Upload the JSON file from a previous run to pick up the adaptive staircases where you left off or explore your
        psychometric functions without running a new experiment.
      </p>
      <label class="file-picker">
        <input type="file" id="session-file" accept="application/json" />
        <span>Select JSON file</span>
      </label>
      <p id="session-status" class="session-status" data-state="info">No previous session loaded.</p>
      <div class="session-actions">
        <button id="start-experiment" class="jspsych-btn">Start experiment</button>
        <button id="view-psychometrics" class="jspsych-btn" disabled>View my psychometrics</button>
      </div>
      <div id="psychometrics-output" class="psychometrics-output" hidden></div>
    </div>
  </div>
  <div id="jspsych-target"></div>

  <script src="../jspsych/dist/jspsych.js"></script>
  <script src="../jspsych/plugins/html-button-response.js"></script>
  <script src="../jspsych/plugins/html-keyboard-response.js"></script>
  <script src="../jspsych/plugins/call-function.js"></script>
  <script src="https://unpkg.com/jsquest-plus@2.1.0/dist/jsQuestPlus.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

  <script>
    const jsPsych = initJsPsych({
      display_element: 'jspsych-target',
      show_progress_bar: true,
      auto_update_progress_bar: false
    });

    const preExperimentOverlay = document.getElementById('pre-experiment');
    const startButton = document.getElementById('start-experiment');
    const viewButton = document.getElementById('view-psychometrics');
    const fileInput = document.getElementById('session-file');
    const statusEl = document.getElementById('session-status');
    const psychOutput = document.getElementById('psychometrics-output');

    const TARGET_ACCURACY = 0.7;
    const GO_PROBABILITY = 1 / 3;
    const TOTAL_TRIALS = 1000;
    const FIRST_STIM_DURATION = 33;
    const SECOND_STIM_DURATION = 33;
    const RESPONSE_WINDOW = 1400;

    let uploadedDataArray = [];
    let previousTrialCount = 0;
    let progressBase = 0;
    let progressTotal = TOTAL_TRIALS;
    let psychCharts = [];
    let experimentRunning = false;
    let hasFinalizedCurrentRun = false;
    let currentHoldInfo = null;

    const stageSide = Math.min(window.innerWidth, window.innerHeight) * 0.7;
    document.documentElement.style.setProperty('--stage-size', `${Math.round(stageSide)}px`);
    const stageCenter = stageSide / 2;
    const stagePadding = Math.max(28, stageSide * 0.06);
    const maxRadius = Math.max(90, stageCenter - stagePadding);
    const minRadius = Math.max(36, maxRadius * 0.28);
    const minDiameter = Math.max(18, stageSide * 0.08);
    const maxDiameter = Math.max(minDiameter + 16, stageSide * 0.32);

    const holdController = (() => {
      const state = {
        isHolding: false,
        source: null,
        since: null,
        pointerId: null
      };
      const waiters = [];
      const releaseHandlers = new Set();
      const changeHandlers = new Set();
      let experimentActive = false;

      const holdButton = document.createElement('button');
      holdButton.id = 'hold-control';
      holdButton.type = 'button';
      holdButton.textContent = 'Hold to Run';
      holdButton.dataset.state = 'idle';

      const stopButton = document.createElement('button');
      stopButton.id = 'stop-control';
      stopButton.type = 'button';
      stopButton.textContent = 'Stop & Download';
      stopButton.disabled = true;

      document.body.appendChild(stopButton);
      document.body.appendChild(holdButton);

      function updateButtons() {
        holdButton.dataset.state = state.isHolding ? 'active' : 'idle';
        holdButton.textContent = state.isHolding ? 'Holding…' : 'Hold to Run';
        stopButton.disabled = state.isHolding || !experimentActive;
      }

      function beginHold(source, event) {
        if (state.isHolding) return;
        state.isHolding = true;
        state.source = source;
        state.since = performance.now();
        state.pointerId = source === 'pointer' && event ? event.pointerId : null;
        updateButtons();
        while (waiters.length) {
          const resolve = waiters.shift();
          resolve({ source: state.source, since: state.since });
        }
        changeHandlers.forEach(handler => handler({ ...state }));
      }

      function finishHold(source, event) {
        if (!state.isHolding) return;
        if (source === 'pointer' && state.pointerId !== null && event && event.pointerId !== state.pointerId) {
          return;
        }
        const start = state.since;
        const releaseTime = performance.now();
        const info = {
          source,
          time: releaseTime,
          since: start,
          holdDuration: start != null ? releaseTime - start : null,
          pointerType: event?.pointerType ?? null,
          key: event?.code ?? null
        };
        state.isHolding = false;
        state.source = null;
        state.since = null;
        state.pointerId = null;
        updateButtons();
        changeHandlers.forEach(handler => handler({ ...state }));
        releaseHandlers.forEach(handler => handler(info));
      }

      holdButton.addEventListener('pointerdown', event => {
        if (event.button !== undefined && event.button !== 0 && event.pointerType !== 'touch') {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        if (typeof holdButton.setPointerCapture === 'function') {
          try {
            holdButton.setPointerCapture(event.pointerId);
          } catch (error) {
            /* noop */
          }
        }
        beginHold('pointer', event);
      });

      const pointerEnd = event => {
        if (event) {
          event.preventDefault();
          event.stopPropagation();
        }
        if (
          event?.pointerId != null &&
          typeof holdButton.releasePointerCapture === 'function' &&
          (typeof holdButton.hasPointerCapture !== 'function' || holdButton.hasPointerCapture(event.pointerId))
        ) {
          holdButton.releasePointerCapture(event.pointerId);
        }
        finishHold('pointer', event);
      };

      holdButton.addEventListener('pointerup', pointerEnd);
      holdButton.addEventListener('pointercancel', pointerEnd);
      holdButton.addEventListener('lostpointercapture', pointerEnd);
      holdButton.addEventListener('contextmenu', event => event.preventDefault());

      const isTextInput = element => {
        if (!element) return false;
        const tag = element.tagName;
        return tag === 'INPUT' || tag === 'TEXTAREA' || element.isContentEditable === true;
      };

      const keydownHandler = event => {
        if (event.code !== 'Space' || isTextInput(event.target)) {
          return;
        }
        if (event.repeat) {
          event.preventDefault();
          return;
        }
        event.preventDefault();
        beginHold('keyboard', event);
      };

      const keyupHandler = event => {
        if (event.code !== 'Space' || isTextInput(event.target)) {
          return;
        }
        event.preventDefault();
        finishHold('keyboard', event);
      };

      window.addEventListener('keydown', keydownHandler, { passive: false });
      window.addEventListener('keyup', keyupHandler, { passive: false });

      function waitForHold() {
        return new Promise(resolve => {
          if (state.isHolding) {
            resolve({ source: state.source, since: state.since });
          } else {
            waiters.push(resolve);
          }
        });
      }

      function onRelease(handler) {
        if (typeof handler !== 'function') {
          return () => {};
        }
        releaseHandlers.add(handler);
        return () => releaseHandlers.delete(handler);
      }

      function onChange(handler) {
        if (typeof handler !== 'function') {
          return () => {};
        }
        changeHandlers.add(handler);
        return () => changeHandlers.delete(handler);
      }

      function setExperimentActive(active) {
        experimentActive = Boolean(active);
        updateButtons();
      }

      updateButtons();

      return {
        waitForHold,
        onRelease,
        onChange,
        isHolding: () => state.isHolding,
        getState: () => ({ ...state }),
        setExperimentActive,
        stopButton,
        holdButton
      };
    })();

    function clamp(value, min, max) {
      return Math.min(max, Math.max(min, value));
    }

    function setStatus(message, state = 'info') {
      if (!statusEl) return;
      statusEl.textContent = message;
      statusEl.dataset.state = state;
    }

    function destroyPsychCharts() {
      psychCharts.forEach(chart => {
        if (chart && typeof chart.destroy === 'function') {
          chart.destroy();
        }
      });
      psychCharts = [];
    }

    function randomBetween(min, max) {
      if (max <= min) {
        return min;
      }
      return min + Math.random() * (max - min);
    }

    function degToRad(deg) {
      return (deg * Math.PI) / 180;
    }

    function wrapAngle(theta) {
      const tau = Math.PI * 2;
      return ((theta % tau) + tau) % tau;
    }

    function polarToCartesian(cx, cy, radius, theta) {
      return {
        x: cx + radius * Math.cos(theta),
        y: cy + radius * Math.sin(theta)
      };
    }

    function createRange(start, end, step) {
      const output = [];
      if (end < start) {
        output.push(parseFloat(start.toFixed(3)));
        return output;
      }
      for (let value = start; value <= end + 1e-6; value += step) {
        output.push(parseFloat(value.toFixed(3)));
      }
      return output;
    }

    const thetaSamples = createRange(4, 72, 2);
    const radiusMaxShift = Math.max(6, Math.min(90, Math.floor(maxRadius - minRadius - 6)));
    const radiusSamples = createRange(6, radiusMaxShift, 2);
    const diameterMaxShift = Math.max(4, Math.min(60, Math.floor(maxDiameter - minDiameter - 4)));
    const diameterSamples = createRange(4, diameterMaxShift, 2);
    const slopeSamples = createRange(2, 5, 0.5);
    const guessRate = [0.01];
    const lapseRate = [0.05];

    function buildQuest(stimSamples) {
      return new jsQuestPlus({
        psych_func: [
          (stim, threshold, slope, guess, lapse) => jsQuestPlus.weibull(stim, threshold, slope, guess, lapse),
          (stim, threshold, slope, guess, lapse) => 1 - jsQuestPlus.weibull(stim, threshold, slope, guess, lapse)
        ],
        stim_samples: [stimSamples],
        psych_samples: [stimSamples, slopeSamples, guessRate, lapseRate]
      });
    }

    let thetaQuest = buildQuest(thetaSamples);
    let radiusQuest = buildQuest(radiusSamples);
    let diameterQuest = buildQuest(diameterSamples);

    function resetQuests() {
      thetaQuest = buildQuest(thetaSamples);
      radiusQuest = buildQuest(radiusSamples);
      diameterQuest = buildQuest(diameterSamples);
    }

    function computeEmpiricalPoints(trials, changeType) {
      const goTrials = trials.filter(
        trial =>
          trial &&
          trial.stage === 'response' &&
          trial.is_go === true &&
          trial.change_type === changeType &&
          typeof trial.quest_value === 'number'
      );
      const grouped = new Map();
      goTrials.forEach(trial => {
        const intensity = Number(trial.quest_value);
        if (!Number.isFinite(intensity)) {
          return;
        }
        const key = intensity.toFixed(3);
        if (!grouped.has(key)) {
          grouped.set(key, { x: intensity, hits: 0, total: 0 });
        }
        const bucket = grouped.get(key);
        if (trial.go_success === true) {
          bucket.hits += 1;
        }
        bucket.total += 1;
      });
      return Array.from(grouped.values())
        .sort((a, b) => a.x - b.x)
        .map(bucket => ({
          x: bucket.x,
          y: bucket.total ? bucket.hits / bucket.total : 0,
          hits: bucket.hits,
          total: bucket.total
        }));
    }

    function seedQuestsFromData(dataArray) {
      resetQuests();
      previousTrialCount = 0;
      if (!Array.isArray(dataArray)) {
        return;
      }
      dataArray.forEach(trial => {
        if (!trial || trial.stage !== 'response') {
          return;
        }
        const trialNumber = Number(trial.trial_number ?? trial.trialIndex ?? trial.trial_index);
        if (Number.isFinite(trialNumber)) {
          previousTrialCount = Math.max(previousTrialCount, trialNumber);
        }
        if (
          trial.is_go !== true ||
          typeof trial.quest_value !== 'number' ||
          !trial.change_type ||
          trial.change_type === 'none'
        ) {
          return;
        }
        const intensity = Number(trial.quest_value);
        if (!Number.isFinite(intensity)) {
          return;
        }
        const quest =
          trial.change_type === 'theta'
            ? thetaQuest
            : trial.change_type === 'radius'
            ? radiusQuest
            : trial.change_type === 'diameter'
            ? diameterQuest
            : null;
        if (!quest) {
          return;
        }
        const responseIndex = trial.go_success === true ? 1 : 0;
        try {
          quest.update(intensity, responseIndex);
        } catch (error) {
          console.warn('Quest update skipped while seeding from previous data', error);
        }
      });
    }

    function renderPsychometricsFromData(dataArray) {
      destroyPsychCharts();
      if (!psychOutput) return;
      psychOutput.innerHTML = '';
      if (!Array.isArray(dataArray) || dataArray.length === 0) {
        psychOutput.innerHTML =
          '<p class="session-status" data-state="warning">The uploaded file does not contain any trials yet.</p>';
        psychOutput.hidden = false;
        return;
      }
      if (typeof Chart === 'undefined') {
        psychOutput.innerHTML =
          '<p class="session-status" data-state="error">Chart.js failed to load, so the psychometric plots are unavailable.</p>';
        psychOutput.hidden = false;
        return;
      }
      const responseTrials = dataArray.filter(trial => trial && trial.stage === 'response');
      if (!responseTrials.length) {
        psychOutput.innerHTML =
          '<p class="session-status" data-state="warning">The uploaded file does not contain any response-stage trials yet.</p>';
        psychOutput.hidden = false;
        return;
      }

      const changeTypes = [
        { key: 'theta', label: 'Angular shift', unit: '°', color: '#38bdf8', quest: () => thetaQuest, samples: thetaSamples },
        { key: 'radius', label: 'Radial displacement', unit: 'px', color: '#22c55e', quest: () => radiusQuest, samples: radiusSamples },
        { key: 'diameter', label: 'Diameter change', unit: 'px', color: '#f97316', quest: () => diameterQuest, samples: diameterSamples }
      ];

      changeTypes.forEach(info => {
        const section = document.createElement('section');
        section.className = 'psych-section';

        const heading = document.createElement('h3');
        heading.textContent = `${info.label} (${info.unit})`;
        section.appendChild(heading);

        const quest = info.quest();
        let estimates = null;
        try {
          const questEstimates = quest.getEstimates('mode');
          if (Array.isArray(questEstimates) && questEstimates.length >= 4) {
            estimates = questEstimates;
          }
        } catch (error) {
          console.warn('Quest estimates unavailable', error);
        }

        const summary = document.createElement('p');
        if (estimates) {
          summary.innerHTML = `<strong>Estimated threshold:</strong> ${estimates[0].toFixed(2)} ${info.unit} · <strong>Slope:</strong> ${estimates[1].toFixed(2)}`;
        } else {
          summary.textContent = 'Not enough data to estimate a psychometric function yet.';
        }
        section.appendChild(summary);

        const canvas = document.createElement('canvas');
        section.appendChild(canvas);
        psychOutput.appendChild(section);

        const empirical = computeEmpiricalPoints(responseTrials, info.key);
        const datasets = [];

        if (estimates) {
          const predicted = info.samples.map(value => ({
            x: value,
            y: jsQuestPlus.weibull(value, estimates[0], estimates[1], estimates[2], estimates[3])
          }));
          datasets.push({
            label: `${info.label} fit`,
            data: predicted,
            fill: false,
            borderColor: info.color,
            backgroundColor: info.color,
            tension: 0.25,
            parsing: false
          });
        }

        if (empirical.length) {
          datasets.push({
            label: `${info.label} empirical`,
            data: empirical.map(point => ({ x: point.x, y: point.y })),
            parsing: false,
            showLine: false,
            backgroundColor: 'rgba(248, 250, 252, 0.85)',
            borderColor: '#f8fafc',
            pointRadius: 4,
            pointHoverRadius: 6
          });
        }

        const chart = new Chart(canvas.getContext('2d'), {
          type: 'line',
          data: { datasets },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                title: { display: true, text: `${info.label} (${info.unit})`, color: '#cbd5f5' },
                grid: { color: 'rgba(148, 163, 184, 0.2)' },
                ticks: { color: '#e2e8f0' }
              },
              y: {
                min: 0,
                max: 1,
                title: { display: true, text: 'Detection probability', color: '#cbd5f5' },
                grid: { color: 'rgba(148, 163, 184, 0.2)' },
                ticks: {
                  color: '#e2e8f0',
                  callback: value => `${Math.round(value * 100)}%`
                }
              }
            },
            plugins: {
              legend: { labels: { color: '#e2e8f0' } },
              tooltip: {
                callbacks: {
                  label(context) {
                    const datasetLabel = context.dataset.label || '';
                    const yValue = context.parsed.y;
                    let base = `${datasetLabel}: ${Math.round(yValue * 100)}% at ${context.parsed.x.toFixed(2)} ${info.unit}`;
                    if (
                      context.dataset.label &&
                      context.dataset.label.includes('empirical') &&
                      typeof context.dataIndex === 'number' &&
                      empirical[context.dataIndex]
                    ) {
                      const point = empirical[context.dataIndex];
                      base += ` (${point.hits}/${point.total} detections)`;
                    }
                    return base;
                  }
                }
              }
            }
          }
        });

        psychCharts.push(chart);
      });

      psychOutput.hidden = false;
    }

    function downloadBlob(content, filename, type) {
      const blob = new Blob([content], { type });
      const url = URL.createObjectURL(blob);
      const anchor = document.createElement('a');
      anchor.href = url;
      anchor.download = filename;
      anchor.rel = 'noopener';
      document.body.appendChild(anchor);
      anchor.click();
      document.body.removeChild(anchor);
      setTimeout(() => URL.revokeObjectURL(url), 0);
    }

    function chooseStimulus(quest, samples) {
      let chosen = quest.getStimParams();
      try {
        const estimates = quest.getEstimates('mode');
        if (Array.isArray(estimates) && estimates.length >= 4) {
          let best = chosen;
          let bestDiff = Infinity;
          for (const value of samples) {
            const prob = jsQuestPlus.weibull(value, estimates[0], estimates[1], estimates[2], estimates[3]);
            const diff = Math.abs(prob - TARGET_ACCURACY);
            if (diff < bestDiff) {
              bestDiff = diff;
              best = value;
            }
          }
          chosen = best;
        }
      } catch (error) {
        console.warn('Quest estimate unavailable', error);
      }
      return chosen;
    }

    function stageHTML(content = '') {
      return `<div class="stage">${content}</div>`;
    }

    function createDotColor() {
      const hue = Math.floor(Math.random() * 360);
      return {
        fill: `hsl(${hue}, 85%, 70%)`,
        glow: `hsla(${hue}, 85%, 70%, 0.65)`
      };
    }

    function dotHTML(x, y, diameter, color = { fill: '#f8fafc', glow: 'rgba(248, 250, 252, 0.65)' }) {
      return `<div class="dot" style="left:${x}px; top:${y}px; width:${diameter}px; height:${diameter}px; background:${color.fill}; box-shadow:0 0 20px ${color.glow};"></div>`;
    }

    function finalizeSession({ reason = 'completed', showOverlay = true } = {}) {
      if (hasFinalizedCurrentRun) {
        return [];
      }
      hasFinalizedCurrentRun = true;
      experimentRunning = false;
      holdController.setExperimentActive(false);
      currentHoldInfo = null;

      jsPsych.setProgressBar(1);

      const newValues = jsPsych.data ? jsPsych.data.get().values() : [];
      const combined = uploadedDataArray.length ? [...uploadedDataArray, ...newValues] : [...newValues];
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');

      downloadBlob(JSON.stringify(combined, null, 2), `jnd-go-nogo-${timestamp}.json`, 'application/json');
      if (newValues.length && reason !== 'stopped') {
        downloadBlob(jsPsych.data.get().csv(), `jnd-go-nogo-${timestamp}.csv`, 'text/csv');
      }

      uploadedDataArray = combined;
      seedQuestsFromData(uploadedDataArray);
      progressBase = previousTrialCount;
      progressTotal = previousTrialCount + TOTAL_TRIALS;

      if (viewButton) {
        viewButton.disabled = uploadedDataArray.length === 0;
      }
      if (startButton) {
        startButton.textContent = 'Run another block';
      }

      const statusMessage =
        reason === 'stopped'
          ? 'Experiment stopped. Your data has been downloaded.'
          : 'Block completed. Your data has been downloaded.';
      setStatus(statusMessage, 'info');

      if (showOverlay && preExperimentOverlay) {
        preExperimentOverlay.classList.remove('hidden');
      }
      if (psychOutput) {
        psychOutput.hidden = true;
      }
      destroyPsychCharts();

      const display = jsPsych.getDisplayElement();
      if (display) {
        display.innerHTML = '';
      }

      if (typeof trialState.releaseCleanup === 'function') {
        try {
          trialState.releaseCleanup();
        } catch (error) {
          /* ignore */
        }
        trialState.releaseCleanup = null;
      }
      trialState.responseInfo = null;
      trialState.pendingRelease = null;

      return combined;
    }

    let trialState = {};

    const instructions = {
      type: jsPsychHtmlButtonResponse,
      stimulus: () => {
        const continuation = previousTrialCount
          ? `<p style="color: rgba(148, 163, 184, 0.88);">Continuing from trial ${previousTrialCount + 1} with your uploaded staircases.</p>`
          : '';
        return `
          <h1 style="margin-top:0">Just Noticeable Difference (Go/No-Go)</h1>
          <p>
            A coloured dot will flash twice. The first (odd-index) flash always marks the reference position and size.
            After a brief random delay (50–1000 ms) the dot reappears in the same hue for the even-index comparison dot.
          </p>
          <p>
            On most trials the dot is identical (<strong>no-go</strong>). About one third of the time the
            dot shifts slightly in angle, distance from the centre, or diameter (<strong>go</strong> trials).
          </p>
          <ul>
            <li>Hold the on-screen <strong>Hold to Run</strong> control (lower right) or keep the space bar held down to let trials play continuously.</li>
            <li>Release the control as soon as the second flash looks different. Maintaining the hold signals “no change”.</li>
            <li>While released you can tap the upper-left <strong>Stop &amp; Download</strong> button to end early and save everything collected so far.</li>
          </ul>
          <p>
            The stimulus differences adapt during the experiment to maintain roughly 70% accuracy on go trials using the jsQuestPlus staircase.
          </p>
          <p>Find a comfortable viewing distance and rest your finger on the hold control or space bar between trials.</p>
          ${continuation}
        `;
      },
      choices: ['Begin']
    };

    function createTrial(index, offset = 0) {
      const awaitHold = {
        type: jsPsychCallFunction,
        async: true,
        func: done => {
          holdController.waitForHold().then(state => {
            currentHoldInfo = state ? { ...state } : null;
            done();
          });
        }
      };

      function handleReleaseEvent(info) {
        if (!info) return;
        trialState.lastRelease = info;
        if (!trialState.responseActive || !trialState.responseInfo) {
          trialState.pendingRelease = info;
          return;
        }
        if (trialState.responseInfo.responded) {
          return;
        }

        const responseSource = info.source || (info.key ? 'keyboard' : 'pointer');
        const base =
          typeof trialState.changeOnset === 'number' ? trialState.changeOnset : trialState.responseInfo.start;
        const rt = base != null ? Math.max(0, info.time - base) : null;

        trialState.responseInfo.responded = true;
        trialState.responseInfo.source = responseSource;
        trialState.responseInfo.rt = rt;
        trialState.responseInfo.holdDuration =
          typeof info.holdDuration === 'number'
            ? info.holdDuration
            : info.since != null
            ? info.time - info.since
            : null;
        trialState.responseInfo.releaseTime = info.time;
        trialState.responseInfo.pointerType = info.pointerType ?? null;
        trialState.responseInfo.key = info.key ?? null;
        trialState.pendingRelease = null;

        jsPsych.finishTrial({ rt, response: responseSource });
      }

      const setup = {
        type: jsPsychCallFunction,
        func: () => {
          const total = Math.max(progressTotal, 1);
          jsPsych.setProgressBar((progressBase + index) / total);

          const holdInfo = currentHoldInfo ? { ...currentHoldInfo } : null;

          trialState = {
            index: offset + index + 1,
            holdInfo,
            holdSource: holdInfo?.source ?? 'none',
            holdStart: holdInfo?.since ?? null,
            isGo: Math.random() < GO_PROBABILITY,
            isi: jsPsych.randomization.randomInt(50, 1000),
            changeType: 'none',
            questStimValue: null,
            questRef: null,
            deltaTheta: 0,
            deltaRadius: 0,
            deltaDiameter: 0,
            pendingRelease: null,
            responseActive: false,
            responseInfo: null,
            releaseCleanup: null,
            changeOnset: null,
            lastRelease: null,
            trialStart: performance.now()
          };

          const dotColor = createDotColor();
          trialState.dotColor = dotColor;

          let baseTheta = Math.random() * Math.PI * 2;
          let baseRadius = randomBetween(minRadius, maxRadius);
          let baseDiameter = randomBetween(minDiameter, maxDiameter);
          let secondTheta = baseTheta;
          let secondRadius = baseRadius;
          let secondDiameter = baseDiameter;

          if (trialState.isGo) {
            const changeOptions = ['theta', 'radius', 'diameter'];
            const selected = jsPsych.randomization.sampleWithoutReplacement(changeOptions, 1)[0];
            trialState.changeType = selected;

            if (selected === 'theta') {
              const stim = chooseStimulus(thetaQuest, thetaSamples);
              trialState.questStimValue = stim;
              trialState.questRef = thetaQuest;
              trialState.deltaTheta = stim;
              const direction = jsPsych.randomization.sampleWithoutReplacement([-1, 1], 1)[0];
              secondTheta = wrapAngle(baseTheta + direction * degToRad(stim));
            } else if (selected === 'radius') {
              const stim = chooseStimulus(radiusQuest, radiusSamples);
              const directions = [];
              if (maxRadius - stim >= minRadius) directions.push(1);
              if (minRadius + stim <= maxRadius) directions.push(-1);
              if (directions.length > 0) {
                const direction = jsPsych.randomization.sampleWithoutReplacement(directions, 1)[0];
                if (direction === 1) {
                  baseRadius = randomBetween(minRadius, maxRadius - stim);
                  secondRadius = baseRadius + stim;
                } else {
                  baseRadius = randomBetween(minRadius + stim, maxRadius);
                  secondRadius = baseRadius - stim;
                }
                trialState.deltaRadius = stim;
                trialState.questStimValue = stim;
                trialState.questRef = radiusQuest;
              }
            } else if (selected === 'diameter') {
              const stim = chooseStimulus(diameterQuest, diameterSamples);
              const directions = [];
              if (maxDiameter - stim >= minDiameter) directions.push(1);
              if (minDiameter + stim <= maxDiameter) directions.push(-1);
              if (directions.length > 0) {
                const direction = jsPsych.randomization.sampleWithoutReplacement(directions, 1)[0];
                if (direction === 1) {
                  baseDiameter = randomBetween(minDiameter, maxDiameter - stim);
                  secondDiameter = baseDiameter + stim;
                } else {
                  baseDiameter = randomBetween(minDiameter + stim, maxDiameter);
                  secondDiameter = baseDiameter - stim;
                }
                trialState.deltaDiameter = stim;
                trialState.questStimValue = stim;
                trialState.questRef = diameterQuest;
              }
            }
          }

          const firstCoords = polarToCartesian(stageCenter, stageCenter, baseRadius, baseTheta);
          const secondCoords = polarToCartesian(stageCenter, stageCenter, secondRadius, secondTheta);

          trialState.baseTheta = baseTheta;
          trialState.baseRadius = baseRadius;
          trialState.baseDiameter = baseDiameter;
          trialState.secondTheta = secondTheta;
          trialState.secondRadius = secondRadius;
          trialState.secondDiameter = secondDiameter;
          trialState.firstX = firstCoords.x;
          trialState.firstY = firstCoords.y;
          trialState.secondX = secondCoords.x;
          trialState.secondY = secondCoords.y;

          if (trialState.releaseCleanup) {
            trialState.releaseCleanup();
          }
          trialState.releaseCleanup = holdController.onRelease(handleReleaseEvent);
        }
      };

      const fixation = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: () => stageHTML('<div class="fixation">+</div>'),
        choices: 'NO_KEYS',
        trial_duration: 350,
        data: { stage: 'fixation' }
      };

      const firstStim = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: () => stageHTML(dotHTML(trialState.firstX, trialState.firstY, trialState.baseDiameter, trialState.dotColor)),
        choices: 'NO_KEYS',
        trial_duration: FIRST_STIM_DURATION,
        data: { stage: 'stimulus_1', trial_index: trialState.index }
      };

      const isi = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: () => stageHTML(),
        choices: 'NO_KEYS',
        trial_duration: () => trialState.isi,
        data: { stage: 'isi' }
      };

      const secondStim = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: () =>
          stageHTML(dotHTML(trialState.secondX, trialState.secondY, trialState.secondDiameter, trialState.dotColor)),
        choices: 'NO_KEYS',
        trial_duration: SECOND_STIM_DURATION,
        data: { stage: 'stimulus_2', trial_index: trialState.index },
        on_load: () => {
          trialState.changeOnset = performance.now();
        }
      };

      const response = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: () => stageHTML(),
        choices: 'NO_KEYS',
        trial_duration: RESPONSE_WINDOW,
        data: { stage: 'response' },
        on_load: () => {
          trialState.responseActive = true;
          trialState.responseInfo = {
            responded: false,
            source: 'none',
            rt: null,
            holdDuration: null,
            start: performance.now(),
            releaseTime: null,
            pointerType: null,
            key: null
          };

          if (trialState.pendingRelease) {
            const pending = trialState.pendingRelease;
            trialState.pendingRelease = null;
            handleReleaseEvent(pending);
          }
        },
        on_finish: data => {
          trialState.responseActive = false;
          if (typeof trialState.releaseCleanup === 'function') {
            trialState.releaseCleanup();
            trialState.releaseCleanup = null;
          }

          const responded = Boolean(trialState.responseInfo?.responded);
          const rt = trialState.responseInfo?.rt ?? null;
          const source = responded ? trialState.responseInfo?.source : 'none';

          data.rt = rt;
          data.response_source = source;
          data.hold_source = trialState.holdSource;
          data.hold_start = trialState.holdStart ?? null;
          data.hold_duration = trialState.responseInfo?.holdDuration ?? null;
          data.release_time = trialState.responseInfo?.releaseTime ?? null;
          data.release_pointer_type = trialState.responseInfo?.pointerType ?? null;
          data.release_key = trialState.responseInfo?.key ?? null;
          data.released_before_change =
            typeof trialState.changeOnset === 'number' && trialState.lastRelease
              ? trialState.lastRelease.time < trialState.changeOnset
              : false;
          data.trial_started = trialState.trialStart ?? null;
          data.is_go = trialState.isGo;
          data.change_type = trialState.changeType;
          data.delta_theta = trialState.deltaTheta;
          data.delta_radius = trialState.deltaRadius;
          data.delta_diameter = trialState.deltaDiameter;
          data.first_theta = trialState.baseTheta;
          data.first_radius = trialState.baseRadius;
          data.first_diameter = trialState.baseDiameter;
          data.second_theta = trialState.secondTheta;
          data.second_radius = trialState.secondRadius;
          data.second_diameter = trialState.secondDiameter;
          data.dot_color = trialState.dotColor?.fill ?? null;
          data.interstimulus = trialState.isi;
          data.trial_number = trialState.index;
          data.go_success = trialState.isGo ? responded : null;
          data.correct = trialState.isGo ? responded : !responded;
          data.quest_value = trialState.questStimValue;

          if (trialState.isGo && trialState.questRef && typeof trialState.questStimValue === 'number') {
            const responseIndex = responded ? 1 : 0;
            try {
              trialState.questRef.update(trialState.questStimValue, responseIndex);
            } catch (error) {
              console.warn('Quest update skipped', error);
            }
          }

          trialState.responseInfo = null;
          trialState.pendingRelease = null;
        }
      };

      return [awaitHold, setup, fixation, firstStim, isi, secondStim, response];
    }

    const completeBlock = {
      type: jsPsychCallFunction,
      func: () => {
        finalizeSession({ reason: 'completed' });
      }
    };

    function buildTimeline(offset = 0) {
      const timeline = [instructions];
      for (let i = 0; i < TOTAL_TRIALS; i++) {
        timeline.push(...createTrial(i, offset));
      }
      timeline.push(completeBlock);
      return timeline;
    }

    function startExperiment() {
      hasFinalizedCurrentRun = false;
      experimentRunning = true;
      currentHoldInfo = null;
      holdController.setExperimentActive(true);
      progressBase = previousTrialCount;
      progressTotal = previousTrialCount + TOTAL_TRIALS;
      const timeline = buildTimeline(previousTrialCount);
      if (preExperimentOverlay) {
        preExperimentOverlay.classList.add('hidden');
      }
      destroyPsychCharts();
      if (psychOutput) {
        psychOutput.hidden = true;
      }
      jsPsych.run(timeline);
    }

    holdController.stopButton.addEventListener('click', () => {
      if (holdController.isHolding() || !experimentRunning || hasFinalizedCurrentRun) {
        return;
      }
      jsPsych.endExperiment('Experiment stopped. Preparing download…');
      finalizeSession({ reason: 'stopped' });
    });

    if (startButton) {
      startButton.addEventListener('click', () => {
        startExperiment();
      });
    }

    if (viewButton) {
      viewButton.addEventListener('click', () => {
        if (viewButton.disabled) return;
        renderPsychometricsFromData(uploadedDataArray);
      });
    }

    if (fileInput) {
      fileInput.addEventListener('change', event => {
        destroyPsychCharts();
        if (psychOutput) {
          psychOutput.hidden = true;
        }

        const files = event.target.files || [];
        const file = files[0];
        if (!file) {
          uploadedDataArray = [];
          previousTrialCount = 0;
          resetQuests();
          progressBase = 0;
          progressTotal = TOTAL_TRIALS;
          if (startButton) startButton.textContent = 'Start experiment';
          if (viewButton) viewButton.disabled = true;
          setStatus('No previous session loaded.', 'info');
          return;
        }

        const reader = new FileReader();
        reader.onload = loadEvent => {
          try {
            const raw = JSON.parse(loadEvent.target.result);
            const normalised = Array.isArray(raw)
              ? raw
              : Array.isArray(raw.data)
              ? raw.data
              : Array.isArray(raw.trials)
              ? raw.trials
              : [];
            if (!Array.isArray(normalised)) {
              throw new Error('Invalid JSON structure');
            }
            uploadedDataArray = normalised.filter(entry => entry && typeof entry === 'object');
            seedQuestsFromData(uploadedDataArray);
            progressBase = previousTrialCount;
            progressTotal = previousTrialCount + TOTAL_TRIALS;
            const responseCount = uploadedDataArray.filter(trial => trial && trial.stage === 'response').length;
            let message = `Loaded ${uploadedDataArray.length} trials from ${file.name}.`;
            if (previousTrialCount) {
              message += ` Continuing from trial ${previousTrialCount + 1}.`;
            }
            if (responseCount) {
              message += ` ${responseCount} response-stage records detected.`;
            }
            setStatus(message, 'info');
            if (startButton) {
              startButton.textContent = uploadedDataArray.length ? 'Continue experiment' : 'Start experiment';
            }
            if (viewButton) {
              viewButton.disabled = uploadedDataArray.length === 0;
            }
          } catch (error) {
            console.error(error);
            uploadedDataArray = [];
            previousTrialCount = 0;
            resetQuests();
            progressBase = 0;
            progressTotal = TOTAL_TRIALS;
            if (startButton) startButton.textContent = 'Start experiment';
            if (viewButton) viewButton.disabled = true;
            setStatus('Could not parse that JSON file. Please ensure it was exported from this experiment.', 'error');
          } finally {
            fileInput.value = '';
          }
        };
        reader.onerror = () => {
          uploadedDataArray = [];
          previousTrialCount = 0;
          resetQuests();
          progressBase = 0;
          progressTotal = TOTAL_TRIALS;
          if (startButton) startButton.textContent = 'Start experiment';
          if (viewButton) viewButton.disabled = true;
          setStatus('Unable to read the selected file.', 'error');
          fileInput.value = '';
        };
        reader.readAsText(file);
      });
    }

    setStatus('No previous session loaded.', 'info');
  </script>
</body>
</html>
