<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Just Noticeable Difference Go/No-Go</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="../jspsych/css/jspsych.css" />
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Inter", "Helvetica Neue", Arial, sans-serif;
      --bg: radial-gradient(circle at top, #0f172a 0%, #111827 60%, #020617 100%);
      --card-bg: rgba(15, 23, 42, 0.9);
      --accent: #38bdf8;
      --stage-size: min(68vw, 68vh);
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg);
      color: #e2e8f0;
      padding: clamp(16px, 4vw, 48px);
    }

    #pre-experiment {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.96) 0%, rgba(2, 6, 23, 0.94) 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: clamp(24px, 6vw, 72px);
      z-index: 10;
      transition: opacity 220ms ease;
    }

    #pre-experiment.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .session-card {
      width: min(92vw, 720px);
      background: rgba(15, 23, 42, 0.85);
      border-radius: clamp(24px, 4vw, 36px);
      box-shadow: 0 30px 70px rgba(2, 6, 23, 0.6);
      padding: clamp(28px, 6vw, 56px);
      display: flex;
      flex-direction: column;
      gap: clamp(16px, 4vw, 28px);
    }

    .session-card h1 {
      margin: 0;
      font-size: clamp(1.6rem, 4vw, 2.15rem);
    }

    .session-card p {
      margin: 0;
      color: rgba(203, 213, 225, 0.92);
    }

    .file-picker {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 999px;
      padding: 0;
      overflow: hidden;
      width: fit-content;
      background: rgba(148, 163, 184, 0.12);
      border: 1px solid rgba(148, 163, 184, 0.18);
      cursor: pointer;
    }

    .file-picker input[type='file'] {
      position: absolute;
      inset: 0;
      opacity: 0;
      cursor: pointer;
    }

    .file-picker span {
      padding: 12px 24px;
      font-weight: 600;
      color: #e2e8f0;
      font-size: clamp(0.95rem, 2.4vw, 1.05rem);
    }

    .session-status {
      margin: 0;
      font-size: clamp(0.95rem, 2.6vw, 1.05rem);
      color: rgba(148, 163, 184, 0.88);
    }

    .session-status[data-state='error'] {
      color: #fca5a5;
    }

    .session-status[data-state='warning'] {
      color: #facc15;
    }

    .session-status strong {
      color: #f8fafc;
    }

    .session-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
    }

    .session-actions .jspsych-btn:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }

    .psychometrics-output {
      border-top: 1px solid rgba(148, 163, 184, 0.18);
      padding-top: clamp(16px, 4vw, 28px);
      display: flex;
      flex-direction: column;
      gap: clamp(16px, 4vw, 24px);
    }

    #jspsych-target {
      width: min(96vw, 860px);
      background: rgba(15, 23, 42, 0.82);
      backdrop-filter: blur(18px);
      border-radius: 32px;
      box-shadow: 0 24px 60px rgba(2, 6, 23, 0.55);
      padding: clamp(24px, 5vw, 56px);
    }

    .jspsych-display-element {
      font-size: clamp(18px, 3vw, 22px);
      line-height: 1.7;
    }

    .jspsych-btn {
      font-size: clamp(1rem, 2.6vw, 1.15rem);
      padding: clamp(12px, 3vw, 16px) clamp(24px, 5vw, 36px);
      border-radius: 999px;
      border: none;
      background: linear-gradient(135deg, var(--accent), #2563eb);
      color: white;
      font-weight: 600;
      box-shadow: inset 0 -2px 0 rgba(15, 23, 42, 0.25);
      transition: transform 160ms ease, box-shadow 160ms ease;
      touch-action: manipulation;
    }

    .jspsych-btn:active {
      transform: translateY(2px);
      box-shadow: inset 0 2px 0 rgba(15, 23, 42, 0.35);
    }

    .stage {
      position: relative;
      width: var(--stage-size);
      height: var(--stage-size);
      margin: 0 auto;
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.95) 0%, rgba(2, 6, 23, 0.88) 80%);
      border-radius: clamp(24px, 6vw, 36px);
      box-shadow: inset 0 0 0 2px rgba(148, 163, 184, 0.08), 0 24px 60px rgba(2, 6, 23, 0.6);
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .dot {
      position: absolute;
      left: 50%;
      top: 50%;
      border-radius: 999px;
      background: #f8fafc;
      box-shadow: 0 0 20px rgba(248, 250, 252, 0.65);
      transform: translate(-50%, -50%);
      will-change: transform;
    }

    .fixation {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      font-size: clamp(36px, 7vw, 64px);
      font-weight: 600;
      color: rgba(241, 245, 249, 0.85);
      text-shadow: 0 8px 30px rgba(15, 23, 42, 0.7);
      pointer-events: none;
    }

    .response-text {
      font-size: clamp(18px, 3.2vw, 24px);
      color: rgba(226, 232, 240, 0.94);
      text-align: center;
      padding: 24px;
    }

    .trial-progress {
      font-size: clamp(14px, 2.5vw, 16px);
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(148, 163, 184, 0.8);
      text-align: center;
      margin-bottom: 16px;
    }

    .control-button {
      position: fixed;
      z-index: 30;
      border: none;
      font-family: inherit;
      font-weight: 600;
      letter-spacing: 0.01em;
      border-radius: clamp(18px, 4vw, 26px);
      box-shadow: 0 18px 40px rgba(2, 6, 23, 0.45);
      cursor: pointer;
      transition: transform 160ms ease, box-shadow 160ms ease, background 160ms ease;
      pointer-events: auto;
      touch-action: manipulation;
      user-select: none;
    }

    .control-button:active {
      transform: translateY(2px);
      box-shadow: 0 8px 24px rgba(2, 6, 23, 0.35);
    }

    .control-button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      transform: none;
      box-shadow: 0 8px 24px rgba(2, 6, 23, 0.25);
    }

    #hold-button {
      bottom: clamp(24px, 5vw, 48px);
      right: clamp(24px, 5vw, 48px);
      padding: clamp(18px, 4.8vw, 24px) clamp(32px, 7vw, 48px);
      font-size: clamp(1rem, 3vw, 1.3rem);
      background: linear-gradient(135deg, #38bdf8, #2563eb);
      color: #f8fafc;
      min-width: clamp(200px, 40vw, 320px);
      text-align: center;
    }

    #hold-button.holding {
      background: linear-gradient(135deg, #f97316, #ef4444);
    }

    #stop-experiment {
      top: clamp(24px, 5vw, 48px);
      left: clamp(24px, 5vw, 48px);
      padding: clamp(16px, 4vw, 20px) clamp(28px, 6vw, 42px);
      font-size: clamp(0.95rem, 2.8vw, 1.2rem);
      background: rgba(248, 250, 252, 0.9);
      color: #0f172a;
    }

    @media (max-width: 600px) {
      #pre-experiment {
        padding: 20px;
      }

      #jspsych-target {
        padding: clamp(20px, 6vw, 40px);
      }

      .stage {
        border-radius: clamp(20px, 8vw, 32px);
      }
    }
  </style>
</head>
<body>
  <div id="pre-experiment">
    <div class="session-card">
      <h1>Resume or explore your JND session</h1>
      <p>
        Upload the JSON file from a previous run to pick up the adaptive staircases where you left off or explore your
        psychometric functions without running a new experiment.
      </p>
      <label class="file-picker">
        <input type="file" id="session-file" accept="application/json" />
        <span>Select JSON file</span>
      </label>
      <p id="session-status" class="session-status" data-state="info">No previous session loaded.</p>
      <div class="session-actions">
        <button id="start-experiment" class="jspsych-btn">Start experiment</button>
      </div>
      <div id="psychometrics-output" class="psychometrics-output">
        <div style="display:flex; gap:.5rem; align-items:center; margin:.5rem 0; flex-wrap:wrap;">
          <label for="pm-dim">Dimension:</label>
          <select id="pm-dim">
            <option value="theta">Î¸ (angle)</option>
            <option value="radius">radius</option>
            <option value="diameter">diameter</option>
          </select>

          <button id="view-psychometrics" class="jspsych-btn" disabled>View my psychometrics</button>
          <span id="pm-status" style="font-size:.9rem;color:#666;"></span>
        </div>

        <canvas
          id="pm-canvas"
          width="800"
          height="420"
          style="max-width:100%;border:1px solid #eee"
        ></canvas>
      </div>
    </div>
  </div>
  <div id="jspsych-target"></div>
  <button id="stop-experiment" class="control-button" hidden disabled>Stop &amp; Download</button>
  <button id="hold-button" class="control-button" hidden>Hold to Run Trials</button>

  <script src="../jspsych/dist/jspsych.js"></script>
  <script src="../jspsych/plugins/html-button-response.js"></script>
  <script src="../jspsych/plugins/html-keyboard-response.js"></script>
  <script src="../jspsych/plugins/call-function.js"></script>
  <script src="https://unpkg.com/jsquest-plus@2.1.0/dist/jsQuestPlus.js"></script>

  <script>
    const jsPsych = initJsPsych({
      display_element: 'jspsych-target',
      show_progress_bar: true,
      auto_update_progress_bar: false
    });

    const preExperimentOverlay = document.getElementById('pre-experiment');
    const startButton = document.getElementById('start-experiment');
    const fileInput = document.getElementById('session-file');
    const statusEl = document.getElementById('session-status');
    const holdButton = document.getElementById('hold-button');
    const stopExperimentButton = document.getElementById('stop-experiment');

    const TARGET_ACCURACY = 0.7;
    const GO_PROBABILITY = 1 / 3;
    const TOTAL_TRIALS = 1000;
    const FIRST_STIM_DURATION = 33;
    const SECOND_STIM_DURATION = 33;
    const RESPONSE_WINDOW = 1400;

    let uploadedDataArray = [];
    let previousTrialCount = 0;
    let progressBase = 0;
    let progressTotal = TOTAL_TRIALS;
    let sessionRunning = false;
    let sessionFinalized = false;
    let lastHoldStartTime = null;

    window.JND_SESSION = { trials: [] };

    function broadcastSessionUpdate() {
      const trials = Array.isArray(uploadedDataArray) ? [...uploadedDataArray] : [];
      window.JND_SESSION = { trials };
      window.dispatchEvent(new Event('jnd-session-loaded'));
    }

    const stageSide = Math.min(window.innerWidth, window.innerHeight) * 0.7;
    document.documentElement.style.setProperty('--stage-size', `${Math.round(stageSide)}px`);
    const stageCenter = stageSide / 2;
    const stagePadding = Math.max(28, stageSide * 0.06);
    const maxRadius = Math.max(90, stageCenter - stagePadding);
    const minRadius = Math.max(36, maxRadius * 0.28);
    const minDiameter = Math.max(18, stageSide * 0.08);
    const maxDiameter = Math.max(minDiameter + 16, stageSide * 0.32);

    function updateHoldButton(isActive) {
      if (!holdButton) return;
      holdButton.classList.toggle('holding', Boolean(isActive));
      holdButton.setAttribute('aria-pressed', isActive ? 'true' : 'false');
      holdButton.textContent = isActive ? 'Release to Report Change' : 'Hold to Run Trials';
    }

    function updateStopButtonState() {
      if (!stopExperimentButton) return;
      if (!sessionRunning) {
        stopExperimentButton.disabled = true;
        return;
      }
      stopExperimentButton.disabled = holdState.isActive();
    }

    const holdState = {
      sources: new Map(),
      holdStart: null,
      primarySource: 'none',
      holdStartListeners: new Set(),
      releaseListeners: new Set(),
      lastReleaseInfo: null,
      activate(key, source = 'pointer') {
        if (this.sources.has(key)) return;
        const now = performance.now();
        this.sources.set(key, { source, startedAt: now });
        if (this.sources.size === 1) {
          this.holdStart = now;
          this.primarySource = source;
          this.lastReleaseInfo = null;
          updateHoldButton(true);
          updateStopButtonState();
          Array.from(this.holdStartListeners).forEach(listener => {
            try {
              listener({ source, startedAt: now });
            } catch (error) {
              console.error(error);
            }
          });
        }
      },
      release(key, source = 'pointer') {
        if (!this.sources.has(key)) return;
        this.sources.delete(key);
        if (this.sources.size === 0) {
          const now = performance.now();
          const startedAt = this.holdStart;
          const info = {
            source: source || this.primarySource || 'none',
            duration: typeof startedAt === 'number' ? now - startedAt : null,
            startedAt: typeof startedAt === 'number' ? startedAt : null,
            releasedAt: now
          };
          this.holdStart = null;
          this.primarySource = 'none';
          this.lastReleaseInfo = info;
          updateHoldButton(false);
          updateStopButtonState();
          Array.from(this.releaseListeners).forEach(listener => {
            try {
              listener(info);
            } catch (error) {
              console.error(error);
            }
          });
        }
      },
      isActive() {
        return this.sources.size > 0;
      },
      reset() {
        this.sources.clear();
        this.holdStart = null;
        this.primarySource = 'none';
        this.holdStartListeners.clear();
        this.releaseListeners.clear();
        this.lastReleaseInfo = null;
        updateHoldButton(false);
        updateStopButtonState();
      }
    };

    updateHoldButton(false);
    updateStopButtonState();

    const HOLD_KEY = 'keyboard-space';

    if (holdButton) {
      holdButton.addEventListener('pointerdown', event => {
        if (!sessionRunning) return;
        event.preventDefault();
        if (typeof holdButton.setPointerCapture === 'function') {
          try {
            holdButton.setPointerCapture(event.pointerId);
          } catch (error) {
            console.warn('Pointer capture rejected', error);
          }
        }
        holdState.activate(`pointer-${event.pointerId}`, 'pointer');
      });

      const releasePointer = event => {
        if (typeof holdButton.releasePointerCapture === 'function') {
          try {
            holdButton.releasePointerCapture(event.pointerId);
          } catch (error) {
            // Ignored.
          }
        }
        holdState.release(`pointer-${event.pointerId}`, 'pointer');
      };

      holdButton.addEventListener('pointerup', releasePointer);
      holdButton.addEventListener('pointercancel', releasePointer);
      holdButton.addEventListener('lostpointercapture', releasePointer);
    }

    document.addEventListener('keydown', event => {
      if (!sessionRunning) return;
      if (event.code === 'Space' || event.key === ' ') {
        if (event.repeat) return;
        event.preventDefault();
        holdState.activate(HOLD_KEY, 'keyboard');
      }
    });

    document.addEventListener('keyup', event => {
      if (event.code === 'Space' || event.key === ' ') {
        event.preventDefault();
        holdState.release(HOLD_KEY, 'keyboard');
      }
    });

    function clamp(value, min, max) {
      return Math.min(max, Math.max(min, value));
    }

    function setStatus(message, state = 'info') {
      if (!statusEl) return;
      statusEl.textContent = message;
      statusEl.dataset.state = state;
    }

    function randomBetween(min, max) {
      if (max <= min) {
        return min;
      }
      return min + Math.random() * (max - min);
    }

    function degToRad(deg) {
      return (deg * Math.PI) / 180;
    }

    function wrapAngle(theta) {
      const tau = Math.PI * 2;
      return ((theta % tau) + tau) % tau;
    }

    function polarToCartesian(cx, cy, radius, theta) {
      return {
        x: cx + radius * Math.cos(theta),
        y: cy + radius * Math.sin(theta)
      };
    }

    function createRange(start, end, step) {
      const output = [];
      if (end < start) {
        output.push(parseFloat(start.toFixed(3)));
        return output;
      }
      for (let value = start; value <= end + 1e-6; value += step) {
        output.push(parseFloat(value.toFixed(3)));
      }
      return output;
    }

    const thetaSamples = createRange(4, 72, 2);
    const radiusMaxShift = Math.max(6, Math.min(90, Math.floor(maxRadius - minRadius - 6)));
    const radiusSamples = createRange(6, radiusMaxShift, 2);
    const diameterMaxShift = Math.max(4, Math.min(60, Math.floor(maxDiameter - minDiameter - 4)));
    const diameterSamples = createRange(4, diameterMaxShift, 2);
    const slopeSamples = createRange(2, 5, 0.5);
    const guessRate = [0.01];
    const lapseRate = [0.05];

    function buildQuest(stimSamples) {
      return new jsQuestPlus({
        psych_func: [
          (stim, threshold, slope, guess, lapse) => jsQuestPlus.weibull(stim, threshold, slope, guess, lapse),
          (stim, threshold, slope, guess, lapse) => 1 - jsQuestPlus.weibull(stim, threshold, slope, guess, lapse)
        ],
        stim_samples: [stimSamples],
        psych_samples: [stimSamples, slopeSamples, guessRate, lapseRate]
      });
    }

    let thetaQuest = buildQuest(thetaSamples);
    let radiusQuest = buildQuest(radiusSamples);
    let diameterQuest = buildQuest(diameterSamples);

    function resetQuests() {
      thetaQuest = buildQuest(thetaSamples);
      radiusQuest = buildQuest(radiusSamples);
      diameterQuest = buildQuest(diameterSamples);
    }

    function seedQuestsFromData(dataArray) {
      resetQuests();
      previousTrialCount = 0;
      if (!Array.isArray(dataArray)) {
        return;
      }
      dataArray.forEach(trial => {
        if (!trial || trial.stage !== 'response') {
          return;
        }
        const trialNumber = Number(trial.trial_number ?? trial.trialIndex ?? trial.trial_index);
        if (Number.isFinite(trialNumber)) {
          previousTrialCount = Math.max(previousTrialCount, trialNumber);
        }
        if (
          trial.is_go !== true ||
          typeof trial.quest_value !== 'number' ||
          !trial.change_type ||
          trial.change_type === 'none'
        ) {
          return;
        }
        const intensity = Number(trial.quest_value);
        if (!Number.isFinite(intensity)) {
          return;
        }
        const quest =
          trial.change_type === 'theta'
            ? thetaQuest
            : trial.change_type === 'radius'
            ? radiusQuest
            : trial.change_type === 'diameter'
            ? diameterQuest
            : null;
        if (!quest) {
          return;
        }
        const responseIndex = trial.go_success === true ? 1 : 0;
        try {
          quest.update(intensity, responseIndex);
        } catch (error) {
          console.warn('Quest update skipped while seeding from previous data', error);
        }
      });
    }

    function downloadBlob(content, filename, type) {
      const blob = new Blob([content], { type });
      const url = URL.createObjectURL(blob);
      const anchor = document.createElement('a');
      anchor.href = url;
      anchor.download = filename;
      anchor.rel = 'noopener';
      document.body.appendChild(anchor);
      anchor.click();
      document.body.removeChild(anchor);
      setTimeout(() => URL.revokeObjectURL(url), 0);
    }

    function finalizeSession(reason = 'complete') {
      if (sessionFinalized) {
        return;
      }
      sessionFinalized = true;
      sessionRunning = false;
      lastHoldStartTime = null;
      holdState.reset();
      updateStopButtonState();

      if (holdButton) {
        holdButton.hidden = true;
      }
      if (stopExperimentButton) {
        stopExperimentButton.hidden = true;
        stopExperimentButton.disabled = true;
      }

      jsPsych.setProgressBar(1);

      const newValues = jsPsych.data.get().values();
      const combined = uploadedDataArray.length ? [...uploadedDataArray, ...newValues] : [...newValues];
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      if (newValues.length) {
        downloadBlob(JSON.stringify(combined, null, 2), `jnd-go-nogo-${timestamp}.json`, 'application/json');
        downloadBlob(jsPsych.data.get().csv(), `jnd-go-nogo-${timestamp}.csv`, 'text/csv');
      }

      uploadedDataArray = combined;
      seedQuestsFromData(uploadedDataArray);
      progressBase = previousTrialCount;
      progressTotal = previousTrialCount + TOTAL_TRIALS;
      broadcastSessionUpdate();

      if (startButton) {
        startButton.textContent = uploadedDataArray.length ? 'Run another block' : 'Start experiment';
      }

      setStatus(
        newValues.length
          ? `${reason === 'stopped' ? 'Session stopped early.' : 'Session complete.'} Downloaded ${newValues.length} new trials.`
          : `${reason === 'stopped' ? 'Session stopped.' : 'Session ended.'} No new trials were recorded.`,
        'info'
      );

      if (preExperimentOverlay) {
        preExperimentOverlay.classList.remove('hidden');
      }
      jsPsych.getDisplayElement().innerHTML = '';
    }

    function chooseStimulus(quest, samples) {
      let chosen = quest.getStimParams();
      try {
        const estimates = quest.getEstimates('mode');
        if (Array.isArray(estimates) && estimates.length >= 4) {
          let best = chosen;
          let bestDiff = Infinity;
          for (const value of samples) {
            const prob = jsQuestPlus.weibull(value, estimates[0], estimates[1], estimates[2], estimates[3]);
            const diff = Math.abs(prob - TARGET_ACCURACY);
            if (diff < bestDiff) {
              bestDiff = diff;
              best = value;
            }
          }
          chosen = best;
        }
      } catch (error) {
        console.warn('Quest estimate unavailable', error);
      }
      return chosen;
    }

    function stageHTML(content = '', { showFixation = false } = {}) {
      const fixation = showFixation ? '<div class="fixation">+</div>' : '';
      return `<div class="stage">${fixation}${content}</div>`;
    }

    function createDotColor() {
      const hue = Math.floor(Math.random() * 360);
      return {
        fill: `hsl(${hue}, 85%, 70%)`,
        glow: `hsla(${hue}, 85%, 70%, 0.65)`
      };
    }

    function dotHTML(x, y, diameter, color = { fill: '#f8fafc', glow: 'rgba(248, 250, 252, 0.65)' }) {
      return `<div class="dot" style="left:${x}px; top:${y}px; width:${diameter}px; height:${diameter}px; background:${color.fill}; box-shadow:0 0 20px ${color.glow};"></div>`;
    }

    let trialState = {};

    const instructions = {
      type: jsPsychHtmlButtonResponse,
      stimulus: () => {
        const continuation = previousTrialCount
          ? `<p style="color: rgba(148, 163, 184, 0.88);">Continuing from trial ${previousTrialCount + 1} with your uploaded staircases.</p>`
          : '';
        return `
          <h1 style="margin-top:0">Just Noticeable Difference (Go/No-Go)</h1>
          <p>
            A coloured dot will flash twice. The first (odd-index) flash always marks the reference position and size.
            After a brief random delay (50â1000 ms) the dot reappears in the same hue for the even-index comparison dot.
          </p>
          <p>
            On most trials the dot is identical (<strong>no-go</strong>). About one third of the time the
            dot shifts slightly in angle, distance from the centre, or diameter (<strong>go</strong> trials).
          </p>
          <ul>
            <li>Hold the glowing control button in the lower-right corner (or hold the spacebar) to initiate and continue trials.</li>
            <li>Release the button or the spacebar as soon as you detect that the comparison dot differs from the reference.</li>
            <li>If the dots look identical, keep holding the control so the next trial starts immediately.</li>
          </ul>
          <p>
            The stimulus differences adapt during the experiment to maintain roughly 70% accuracy on go trials using the jsQuestPlus staircase.
          </p>
          <p>
            Find a comfortable viewing distance and keep your finger near the screen or the spacebar.
            When you release the control, you can use the large stop button in the upper-left corner to finish the session and download your data.
          </p>
          ${continuation}
        `;
      },
      choices: ['Begin']
    };

    function createTrial(index, offset = 0) {
      let holdGateListener = null;
      const waitForHold = {
        type: jsPsychCallFunction,
        async: true,
        data: { stage: 'hold_gate', trial_index: offset + index + 1 },
        func: callback => {
          const resolve = startedAt => {
            if (holdGateListener) {
              holdState.holdStartListeners.delete(holdGateListener);
              holdGateListener = null;
            }
            lastHoldStartTime = typeof startedAt === 'number' ? startedAt : performance.now();
            callback({ startedAt: lastHoldStartTime });
          };

          if (holdState.isActive()) {
            resolve(holdState.holdStart);
            return;
          }

          const display = jsPsych.getDisplayElement();
          if (display) {
            display.innerHTML = stageHTML(
              '<div class="response-text">Hold the control button or spacebar to begin the next trial.</div>'
            );
          }

          holdGateListener = info => {
            const startedAt = typeof info?.startedAt === 'number' ? info.startedAt : holdState.holdStart;
            resolve(startedAt);
          };
          holdState.holdStartListeners.add(holdGateListener);
        },
        on_finish: data => {
          if (holdGateListener) {
            holdState.holdStartListeners.delete(holdGateListener);
            holdGateListener = null;
          }
          const info = data.value || {};
          if (typeof info.startedAt === 'number') {
            lastHoldStartTime = info.startedAt;
          } else if (typeof holdState.holdStart === 'number') {
            lastHoldStartTime = holdState.holdStart;
          } else {
            lastHoldStartTime = performance.now();
          }
        }
      };
      const setup = {
        type: jsPsychCallFunction,
        func: () => {
          const total = Math.max(progressTotal, 1);
          jsPsych.setProgressBar((progressBase + index) / total);
          const holdStartedAt = typeof lastHoldStartTime === 'number' ? lastHoldStartTime : holdState.holdStart ?? null;
          trialState = {
            index: offset + index + 1,
            isGo: Math.random() < GO_PROBABILITY,
            isi: jsPsych.randomization.randomInt(50, 1000),
            changeType: 'none',
            questStimValue: null,
            questRef: null,
            deltaTheta: 0,
            deltaRadius: 0,
            deltaDiameter: 0,
            holdStartedAt
          };
          lastHoldStartTime = holdStartedAt;

          const dotColor = createDotColor();
          trialState.dotColor = dotColor;

          let baseTheta = Math.random() * Math.PI * 2;
          let baseRadius = randomBetween(minRadius, maxRadius);
          let baseDiameter = randomBetween(minDiameter, maxDiameter);
          let secondTheta = baseTheta;
          let secondRadius = baseRadius;
          let secondDiameter = baseDiameter;

          if (trialState.isGo) {
            const changeOptions = ['theta', 'radius', 'diameter'];
            const selected = jsPsych.randomization.sampleWithoutReplacement(changeOptions, 1)[0];
            trialState.changeType = selected;

            if (selected === 'theta') {
              const stim = chooseStimulus(thetaQuest, thetaSamples);
              trialState.questStimValue = stim;
              trialState.questRef = thetaQuest;
              trialState.deltaTheta = stim;
              const direction = jsPsych.randomization.sampleWithoutReplacement([-1, 1], 1)[0];
              secondTheta = wrapAngle(baseTheta + direction * degToRad(stim));
            } else if (selected === 'radius') {
              const stim = chooseStimulus(radiusQuest, radiusSamples);
              const directions = [];
              if (maxRadius - stim >= minRadius) directions.push(1);
              if (minRadius + stim <= maxRadius) directions.push(-1);
              if (directions.length > 0) {
                const direction = jsPsych.randomization.sampleWithoutReplacement(directions, 1)[0];
                if (direction === 1) {
                  baseRadius = randomBetween(minRadius, maxRadius - stim);
                  secondRadius = baseRadius + stim;
                } else {
                  baseRadius = randomBetween(minRadius + stim, maxRadius);
                  secondRadius = baseRadius - stim;
                }
                trialState.deltaRadius = stim;
                trialState.questStimValue = stim;
                trialState.questRef = radiusQuest;
              }
            } else if (selected === 'diameter') {
              const stim = chooseStimulus(diameterQuest, diameterSamples);
              const directions = [];
              if (maxDiameter - stim >= minDiameter) directions.push(1);
              if (minDiameter + stim <= maxDiameter) directions.push(-1);
              if (directions.length > 0) {
                const direction = jsPsych.randomization.sampleWithoutReplacement(directions, 1)[0];
                if (direction === 1) {
                  baseDiameter = randomBetween(minDiameter, maxDiameter - stim);
                  secondDiameter = baseDiameter + stim;
                } else {
                  baseDiameter = randomBetween(minDiameter + stim, maxDiameter);
                  secondDiameter = baseDiameter - stim;
                }
                trialState.deltaDiameter = stim;
                trialState.questStimValue = stim;
                trialState.questRef = diameterQuest;
              }
            }
          }

          const firstCoords = polarToCartesian(stageCenter, stageCenter, baseRadius, baseTheta);
          const secondCoords = polarToCartesian(stageCenter, stageCenter, secondRadius, secondTheta);

          trialState.baseTheta = baseTheta;
          trialState.baseRadius = baseRadius;
          trialState.baseDiameter = baseDiameter;
          trialState.secondTheta = secondTheta;
          trialState.secondRadius = secondRadius;
          trialState.secondDiameter = secondDiameter;
          trialState.firstX = firstCoords.x;
          trialState.firstY = firstCoords.y;
          trialState.secondX = secondCoords.x;
          trialState.secondY = secondCoords.y;
        }
      };

      const fixation = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: () => stageHTML('', { showFixation: true }),
        choices: 'NO_KEYS',
        trial_duration: 350,
        data: { stage: 'fixation' }
      };

      const firstStim = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: () =>
          stageHTML(dotHTML(trialState.firstX, trialState.firstY, trialState.baseDiameter, trialState.dotColor), {
            showFixation: true
          }),
        choices: 'NO_KEYS',
        trial_duration: FIRST_STIM_DURATION,
        data: { stage: 'stimulus_1', trial_index: trialState.index }
      };

      const isi = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: () => stageHTML('', { showFixation: true }),
        choices: 'NO_KEYS',
        trial_duration: () => trialState.isi,
        data: { stage: 'isi' }
      };

      const secondStim = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: () =>
          stageHTML(dotHTML(trialState.secondX, trialState.secondY, trialState.secondDiameter, trialState.dotColor), {
            showFixation: true
          }),
        choices: 'NO_KEYS',
        trial_duration: SECOND_STIM_DURATION,
        on_load: () => {
          trialState.secondStimOnset = performance.now();
        },
        data: { stage: 'stimulus_2', trial_index: trialState.index }
      };

      const response = {
        type: jsPsychCallFunction,
        async: true,
        data: { stage: 'response' },
        func: callback => {
          const display = jsPsych.getDisplayElement();
          if (display) {
            display.innerHTML = stageHTML();
          }
          const responseStart = performance.now();
          let finished = false;
          let timerId = null;

          const finish = result => {
            if (finished) return;
            finished = true;
            if (result) {
              holdState.lastReleaseInfo = null;
            }
            if (timerId !== null) {
              window.clearTimeout(timerId);
              timerId = null;
            }
            if (trialState.releaseListener) {
              holdState.releaseListeners.delete(trialState.releaseListener);
              trialState.releaseListener = null;
            }
            callback(result);
          };

          const handleRelease = info => {
            const holdStartedAt =
              typeof info?.startedAt === 'number'
                ? info.startedAt
                : typeof trialState.holdStartedAt === 'number'
                ? trialState.holdStartedAt
                : typeof holdState.holdStart === 'number'
                ? holdState.holdStart
                : lastHoldStartTime;
            const holdReleasedAt = typeof info?.releasedAt === 'number' ? info.releasedAt : performance.now();
            const holdDuration =
              typeof info?.duration === 'number'
                ? info.duration
                : holdStartedAt != null && holdReleasedAt != null
                ? holdReleasedAt - holdStartedAt
                : null;
            finish({
              responded: true,
              response_source: info?.source || holdState.primarySource || 'none',
              rt: performance.now() - responseStart,
              hold_started_at: holdStartedAt ?? null,
              hold_released_at: holdReleasedAt ?? null,
              hold_duration: holdDuration ?? null
            });
          };

          trialState.releaseListener = handleRelease;
          holdState.releaseListeners.add(handleRelease);

          const cachedRelease = holdState.lastReleaseInfo;
          if (
            cachedRelease &&
            typeof cachedRelease.releasedAt === 'number' &&
            typeof trialState.secondStimOnset === 'number' &&
            cachedRelease.releasedAt >= trialState.secondStimOnset
          ) {
            handleRelease(cachedRelease);
          }

          if (finished) {
            return;
          }

          timerId = window.setTimeout(() => {
            const holdStartedAt =
              typeof trialState.holdStartedAt === 'number'
                ? trialState.holdStartedAt
                : typeof holdState.holdStart === 'number'
                ? holdState.holdStart
                : lastHoldStartTime;
            const holdDuration =
              holdStartedAt != null ? performance.now() - holdStartedAt : null;
            finish({
              responded: false,
              response_source: 'none',
              rt: null,
              hold_started_at: holdStartedAt ?? null,
              hold_released_at: null,
              hold_duration: holdDuration
            });
          }, RESPONSE_WINDOW);
        },
        on_finish: data => {
          if (trialState.releaseListener) {
            holdState.releaseListeners.delete(trialState.releaseListener);
            trialState.releaseListener = null;
          }
          const result = data.value || {};
          const responded = result.responded === true;
          const rt = typeof result.rt === 'number' ? result.rt : null;
          const holdStartedAt =
            typeof result.hold_started_at === 'number'
              ? result.hold_started_at
              : typeof trialState.holdStartedAt === 'number'
              ? trialState.holdStartedAt
              : lastHoldStartTime;
          const holdReleasedAt =
            typeof result.hold_released_at === 'number'
              ? result.hold_released_at
              : responded && typeof holdStartedAt === 'number'
              ? holdStartedAt + (typeof result.hold_duration === 'number' ? result.hold_duration : rt ?? 0)
              : null;
          const holdDuration =
            typeof result.hold_duration === 'number'
              ? result.hold_duration
              : holdReleasedAt != null && holdStartedAt != null
              ? holdReleasedAt - holdStartedAt
              : null;
          const source = responded ? result.response_source || holdState.primarySource || 'none' : 'none';

          data.rt = rt;
          data.response_source = source;
          data.is_go = trialState.isGo;
          data.change_type = trialState.changeType;
          data.delta_theta = trialState.deltaTheta;
          data.delta_radius = trialState.deltaRadius;
          data.delta_diameter = trialState.deltaDiameter;
          data.first_theta = trialState.baseTheta;
          data.first_radius = trialState.baseRadius;
          data.first_diameter = trialState.baseDiameter;
          data.second_theta = trialState.secondTheta;
          data.second_radius = trialState.secondRadius;
          data.second_diameter = trialState.secondDiameter;
          data.second_onset = typeof trialState.secondStimOnset === 'number' ? trialState.secondStimOnset : null;
          data.dot_color = trialState.dotColor?.fill ?? null;
          data.interstimulus = trialState.isi;
          data.trial_number = trialState.index;
          data.go_success = trialState.isGo ? responded : null;
          data.correct = trialState.isGo ? responded : !responded;
          data.quest_value = trialState.questStimValue;
          data.hold_started_at = typeof holdStartedAt === 'number' ? holdStartedAt : null;
          data.hold_released_at = typeof holdReleasedAt === 'number' ? holdReleasedAt : null;
          data.hold_duration = typeof holdDuration === 'number' ? holdDuration : null;
          data.responded = responded;

          trialState.holdStartedAt = data.hold_started_at;

          if (trialState.isGo && trialState.questRef && typeof trialState.questStimValue === 'number') {
            const responseIndex = responded ? 1 : 0;
            try {
              trialState.questRef.update(trialState.questStimValue, responseIndex);
            } catch (error) {
              console.warn('Quest update skipped', error);
            }
          }
        }
      };

      return [waitForHold, setup, fixation, firstStim, isi, secondStim, response];
    }

    const sessionComplete = {
      type: jsPsychCallFunction,
      data: { stage: 'session_complete' },
      func: () => {
        finalizeSession('complete');
        return { stage: 'session_complete' };
      }
    };

    function buildTimeline(offset = 0) {
      const timeline = [instructions];
      for (let i = 0; i < TOTAL_TRIALS; i++) {
        timeline.push(...createTrial(i, offset));
      }
      timeline.push(sessionComplete);
      return timeline;
    }

    function startExperiment() {
      progressBase = previousTrialCount;
      progressTotal = previousTrialCount + TOTAL_TRIALS;
      const timeline = buildTimeline(previousTrialCount);
      sessionRunning = true;
      sessionFinalized = false;
      lastHoldStartTime = null;
      holdState.reset();
      if (holdButton) {
        holdButton.hidden = false;
      }
      if (stopExperimentButton) {
        stopExperimentButton.hidden = false;
      }
      updateStopButtonState();
      if (preExperimentOverlay) {
        preExperimentOverlay.classList.add('hidden');
      }
      jsPsych.run(timeline);
    }

    if (startButton) {
      startButton.addEventListener('click', () => {
        startExperiment();
      });
    }

    if (stopExperimentButton) {
      stopExperimentButton.addEventListener('click', () => {
        if (stopExperimentButton.disabled) return;
        finalizeSession('stopped');
        jsPsych.endExperiment('');
      });
    }

    if (fileInput) {
      fileInput.addEventListener('change', event => {
        const files = event.target.files || [];
        const file = files[0];
        if (!file) {
          uploadedDataArray = [];
          previousTrialCount = 0;
          resetQuests();
          progressBase = 0;
          progressTotal = TOTAL_TRIALS;
          broadcastSessionUpdate();
          if (startButton) startButton.textContent = 'Start experiment';
          setStatus('No previous session loaded.', 'info');
          return;
        }

        const reader = new FileReader();
        reader.onload = loadEvent => {
          try {
            const raw = JSON.parse(loadEvent.target.result);
            const normalised = Array.isArray(raw)
              ? raw
              : Array.isArray(raw.data)
              ? raw.data
              : Array.isArray(raw.trials)
              ? raw.trials
              : [];
            if (!Array.isArray(normalised)) {
              throw new Error('Invalid JSON structure');
            }
            uploadedDataArray = normalised.filter(entry => entry && typeof entry === 'object');
            seedQuestsFromData(uploadedDataArray);
            progressBase = previousTrialCount;
            progressTotal = previousTrialCount + TOTAL_TRIALS;
            broadcastSessionUpdate();
            const responseCount = uploadedDataArray.filter(trial => trial && trial.stage === 'response').length;
            let message = `Loaded ${uploadedDataArray.length} trials from ${file.name}.`;
            if (previousTrialCount) {
              message += ` Continuing from trial ${previousTrialCount + 1}.`;
            }
            if (responseCount) {
              message += ` ${responseCount} response-stage records detected.`;
            }
            setStatus(message, 'info');
            if (startButton) {
              startButton.textContent = uploadedDataArray.length ? 'Continue experiment' : 'Start experiment';
            }
          } catch (error) {
            console.error(error);
            uploadedDataArray = [];
            previousTrialCount = 0;
            resetQuests();
            progressBase = 0;
            progressTotal = TOTAL_TRIALS;
            broadcastSessionUpdate();
            if (startButton) startButton.textContent = 'Start experiment';
            setStatus('Could not parse that JSON file. Please ensure it was exported from this experiment.', 'error');
          } finally {
            fileInput.value = '';
          }
        };
        reader.onerror = () => {
          uploadedDataArray = [];
          previousTrialCount = 0;
          resetQuests();
          progressBase = 0;
          progressTotal = TOTAL_TRIALS;
          broadcastSessionUpdate();
          if (startButton) startButton.textContent = 'Start experiment';
          setStatus('Unable to read the selected file.', 'error');
          fileInput.value = '';
        };
        reader.readAsText(file);
      });
    }

    setStatus('No previous session loaded.', 'info');
  </script>

  <script>
    (() => {
      function getResponses() {
        const sess = window.JND_SESSION || window.SESSION || window.sessionData || {};
        const trials = Array.isArray(sess) ? sess : sess.trials || sess.data || [];
        const rows = [];
        for (const t of trials || []) {
          if (t && t.stage === 'response') {
            rows.push(t);
          } else if (t && Array.isArray(t.events)) {
            const r = t.events.find(e => e && e.stage === 'response');
            if (r) rows.push(r);
          }
        }
        return rows;
      }

      function questValueFor(response, dim) {
        if (!response) return null;
        const direct = response.quest_value;
        if (direct !== null && direct !== undefined) {
          const numeric = Number(direct);
          if (Number.isFinite(numeric)) {
            return numeric;
          }
        }
        const entries = Array.isArray(response.quest_values) ? response.quest_values : null;
        if (entries) {
          const match = entries.find(entry => entry && entry.key === dim);
          if (match && match.value !== null && match.value !== undefined) {
            const numeric = Number(match.value);
            if (Number.isFinite(numeric)) {
              return numeric;
            }
          }
        }
        return null;
      }

      function psychometricData(responses, dim) {
        const go = responses.filter(r => r && r.is_go === true && r.change_type === dim);
        const byDelta = new Map();
        for (const r of go) {
          const d = questValueFor(r, dim);
          if (!Number.isFinite(d)) continue;
          const cur = byDelta.get(d) || { n: 0, k: 0 };
          cur.n += 1;
          cur.k += r.responded ? 1 : 0;
          byDelta.set(d, cur);
        }
        return [...byDelta.entries()]
          .sort((a, b) => a[0] - b[0])
          .map(([delta, { n, k }]) => ({ delta, p: n ? k / n : 0, n }));
      }

      function falseAlarmRate(responses) {
        const nogo = responses.filter(r => r && r.is_go === false);
        if (!nogo.length) return 0;
        const fa = nogo.filter(r => r.responded).length;
        return fa / nogo.length;
      }

      function drawPsychometric(canvas, series, fa) {
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;
        ctx.clearRect(0, 0, W, H);

        if (!series || series.length === 0) {
          ctx.fillStyle = '#444';
          ctx.font = '16px system-ui, sans-serif';
          ctx.fillText('No data to plot for this dimension.', 16, 32);
          return;
        }

        const pad = { l: 60, r: 20, t: 24, b: 40 };
        const xs = series.map(s => s.delta);
        const ys = series.map(s => s.p);
        const xMin = Math.min(...xs);
        const xMax = Math.max(...xs);
        const yMin = 0;
        const yMax = 1;

        const span = Math.max(1e-9, xMax - xMin || 1);
        const X = x => pad.l + ((W - pad.l - pad.r) * (x - xMin)) / span;
        const Y = y => H - pad.b - ((H - pad.t - pad.b) * (y - yMin)) / (yMax - yMin || 1);

        ctx.strokeStyle = '#bbb';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(pad.l, Y(0));
        ctx.lineTo(W - pad.r, Y(0));
        ctx.moveTo(pad.l, pad.t);
        ctx.lineTo(pad.l, H - pad.b);
        ctx.stroke();

        ctx.strokeStyle = '#eee';
        for (let g = 0; g <= 10; g++) {
          const gy = g / 10;
          ctx.beginPath();
          ctx.moveTo(pad.l, Y(gy));
          ctx.lineTo(W - pad.r, Y(gy));
          ctx.stroke();
        }

        if (fa && fa > 0) {
          ctx.strokeStyle = '#f0a';
          ctx.setLineDash([5, 4]);
          ctx.beginPath();
          ctx.moveTo(pad.l, Y(fa));
          ctx.lineTo(W - pad.r, Y(fa));
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.fillStyle = '#a06';
          ctx.font = '12px system-ui, sans-serif';
          ctx.fillText(`FA â ${fa.toFixed(2)}`, W - pad.r - 80, Y(fa) - 6);
        }

        ctx.strokeStyle = '#08c';
        ctx.fillStyle = '#08c';
        ctx.lineWidth = 2;
        ctx.beginPath();
        series.forEach((point, index) => {
          const x = X(point.delta);
          const y = Y(point.p);
          if (index === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });
        ctx.stroke();

        ctx.font = '12px system-ui, sans-serif';
        for (const s of series) {
          const x = X(s.delta);
          const y = Y(s.p);
          ctx.beginPath();
          ctx.arc(x, y, 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillText(String(s.n), x + 5, y - 6);
        }

        ctx.fillStyle = '#222';
        ctx.font = '14px system-ui, sans-serif';
        ctx.fillText('Î (QUEST)', pad.l, H - 12);
        ctx.save();
        ctx.translate(16, H / 2 + 20);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText('P(respond GO)', 0, 0);
        ctx.restore();

        const tickCount = Math.min(8, series.length);
        const xticks = tickCount
          ? series.map(s => s.delta).filter((_, i) => i % Math.ceil(series.length / tickCount || 1) === 0)
          : [];
        ctx.fillStyle = '#555';
        ctx.font = '12px system-ui, sans-serif';
        xticks.forEach(v => {
          const x = X(v);
          ctx.beginPath();
          ctx.moveTo(x, H - pad.b);
          ctx.lineTo(x, H - pad.b + 4);
          ctx.strokeStyle = '#bbb';
          ctx.stroke();
          ctx.fillText(String(v), x - 8, H - pad.b + 16);
        });

        for (let g = 0; g <= 10; g += 2) {
          const gy = g / 10;
          const y = Y(gy);
          ctx.beginPath();
          ctx.moveTo(pad.l - 4, y);
          ctx.lineTo(pad.l, y);
          ctx.strokeStyle = '#bbb';
          ctx.stroke();
          ctx.fillText(gy.toFixed(1), pad.l - 36, y + 4);
        }

        ctx.font = '16px system-ui, sans-serif';
        ctx.fillText('Psychometric (dimension-filtered)', pad.l, pad.t - 6);
      }

      const btn = document.getElementById('view-psychometrics');
      const sel = document.getElementById('pm-dim');
      const status = document.getElementById('pm-status');
      const canvas = document.getElementById('pm-canvas');

      const optionEntries = sel
        ? Array.from(sel.options).map(opt => [opt.value, opt.textContent.trim()])
        : [
            ['theta', 'Î¸ (angle)'],
            ['radius', 'radius'],
            ['diameter', 'diameter']
          ];
      const dims = optionEntries.map(([value]) => value);
      const labels = Object.fromEntries(optionEntries);

      const formatCounts = counts =>
        optionEntries
          .map(([value, label]) => `${label} ${counts[value] ?? 0}`)
          .join(', ');

      const labelFor = dim => labels[dim] || dim;

      function refreshStatus() {
        const r = getResponses();
        const n = r.length;
        const counts = Object.fromEntries(dims.map(value => [value, 0]));
        for (const t of r) {
          if (t && t.is_go && Object.prototype.hasOwnProperty.call(counts, t.change_type)) {
            counts[t.change_type] += 1;
          }
        }
        if (status) {
          status.textContent = n
            ? `Loaded ${n} response rows â go-trials by dim: ${formatCounts(counts)}`
            : 'No previous session loaded â run the task or load a JSON.';
        }
        if (btn) {
          btn.disabled = n === 0;
        }
      }

      if (btn) {
        btn.addEventListener('click', () => {
          const r = getResponses();
          if (!r.length) {
            drawPsychometric(canvas, [], 0);
            return;
          }
          const dim = sel && sel.value ? sel.value : dims[0];
          const series = psychometricData(r, dim);
          const fa = falseAlarmRate(r);
          const label = labelFor(dim);
          if (status) {
            status.textContent = series.length
              ? `Plotted ${series.length} Î-bins for "${label}" (FAâ${fa.toFixed(2)}).`
              : `No data for "${label}". Try another dimension or run more GO trials.`;
          }
          drawPsychometric(canvas, series, fa);
        });
      }

      refreshStatus();
      window.addEventListener('jnd-session-loaded', refreshStatus);
    })();
  </script>
</body>
</html>
